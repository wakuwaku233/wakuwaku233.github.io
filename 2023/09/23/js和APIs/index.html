<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>js | 薄苏的桃花坞</title><meta name="author" content="薄苏"><meta name="copyright" content="薄苏"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="一、Js基础1.组成123ECMAscript, DOM, BOM 2.输入和输出输出和输入语句： ​	输入：prompt（） ​	输出：alert()  document.write() console.log() 注意：2.外部式、内部式、内联式 3.变量用let关键字声明 4.常量用const关键词声明 注意：const优先，尽量使用const；有了变量先给const，如果后面要修改，再改为">
<meta property="og:type" content="article">
<meta property="og:title" content="js">
<meta property="og:url" content="https://wakuwaku233.github.io/2023/09/23/js%E5%92%8CAPIs/index.html">
<meta property="og:site_name" content="薄苏的桃花坞">
<meta property="og:description" content="一、Js基础1.组成123ECMAscript, DOM, BOM 2.输入和输出输出和输入语句： ​	输入：prompt（） ​	输出：alert()  document.write() console.log() 注意：2.外部式、内部式、内联式 3.变量用let关键字声明 4.常量用const关键词声明 注意：const优先，尽量使用const；有了变量先给const，如果后面要修改，再改为">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://wakuwaku233.github.io/images/bg4.jpg">
<meta property="article:published_time" content="2023-09-23T13:59:44.370Z">
<meta property="article:modified_time" content="2024-09-24T08:14:42.105Z">
<meta property="article:author" content="薄苏">
<meta property="article:tag" content="js">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://wakuwaku233.github.io/images/bg4.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://wakuwaku233.github.io/2023/09/23/js%E5%92%8CAPIs/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'js',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-09-24 16:14:42'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/images/%E9%98%BF%E5%B0%BC%E4%BA%9A.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">8</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/images/bg4.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="薄苏的桃花坞"><span class="site-name">薄苏的桃花坞</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">js</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-09-23T13:59:44.370Z" title="发表于 2023-09-23 21:59:44">2023-09-23</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-09-24T08:14:42.105Z" title="更新于 2024-09-24 16:14:42">2024-09-24</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/web%E5%89%8D%E7%AB%AF/">web前端</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="js"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="一、Js基础"><a href="#一、Js基础" class="headerlink" title="一、Js基础"></a>一、Js基础</h1><h2 id="1-组成123"><a href="#1-组成123" class="headerlink" title="1.组成123"></a>1.组成123</h2><p>ECMAscript, DOM, BOM</p>
<h2 id="2-输入和输出"><a href="#2-输入和输出" class="headerlink" title="2.输入和输出"></a>2.输入和输出</h2><p>输出和输入语句：</p>
<p>​	输入：prompt（）</p>
<p>​	输出：alert()  document.write() console.log()</p>
<p>注意：2.外部式、内部式、内联式</p>
<h2 id="3-变量"><a href="#3-变量" class="headerlink" title="3.变量"></a>3.变量</h2><p>用<strong>let</strong>关键字声明</p>
<h2 id="4-常量"><a href="#4-常量" class="headerlink" title="4.常量"></a>4.常量</h2><p>用<strong>const</strong>关键词声明</p>
<p>注意：const优先，尽量使用const；有了变量先给const，如果后面要修改，再改为let；<strong>数组和对象使用const来声明</strong></p>
<h2 id="5-数据类型"><a href="#5-数据类型" class="headerlink" title="5.数据类型"></a>5.数据类型</h2><p>​	基本数据类型：number 数字型</p>
<p>​							string 字符串型</p>
<p>​							boolean 布尔型</p>
<p>​							undefined 未定义型（例如：let num 声明一个变量未给值）</p>
<p>​							null 空类型</p>
<p>​							BigInt 任意精度的整数</p>
<p>​							Symbol 代表 （一种实例是唯一且不可改变的数据类型）</p>
<p>​	引用数据类型：object 对象 </p>
<p>注意：什么时候出现未定义数据类型？以后开发场景是？</p>
<p>​	1.定义变量未给值就是undefined；2.如果检测变量是undefined就说明没有值传递过来；3.与null的区别：null可加，undefined运算之后得NAN</p>
<h2 id="6-模板字符串"><a href="#6-模板字符串" class="headerlink" title="6.模板字符串"></a>6.模板字符串</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span><span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&#x27;大家好，我叫&#x27;</span> + name + <span class="string">&#x27;, 今年&#x27;</span> + age + <span class="string">&#x27;岁&#x27;</span>)</span><br><span class="line"><span class="number">2.</span><span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">`大家好，我叫<span class="subst">$&#123;name&#125;</span>，今年<span class="subst">$&#123;age&#125;</span>岁`</span>)</span><br></pre></td></tr></table></figure>

<h2 id="7-控制台输出语句和检测数据类型"><a href="#7-控制台输出语句和检测数据类型" class="headerlink" title="7.控制台输出语句和检测数据类型"></a>7.控制台输出语句和检测数据类型</h2><p>通过typeof关键字检测数据类型。</p>
<p>两种形式：1.作为运算符：typeof x（常用的写法）</p>
<p>​				2.函数形式：typeof(x)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> age = <span class="number">18</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> age)</span><br></pre></td></tr></table></figure>

<h2 id="8-隐式转换"><a href="#8-隐式转换" class="headerlink" title="8.隐式转换"></a>8.隐式转换</h2><p>某些运算符被执行时，系统内部自动将数据类型进行转换，这种转换称为隐式转换。</p>
<p><strong>规则</strong>：</p>
<ul>
<li>+号两边只要有一个是字符串，都会把另外一个转成字符串</li>
<li>除了+以外的算术运算符 比如 - * &#x2F; 等都会把数据转成数字类型</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>转换类型不明确，靠经验才能总结</li>
</ul>
<p><strong>小技巧</strong>：</p>
<ul>
<li><u>+号作为正号解析可以转换成数字型</u><ul>
<li><u>任何数据和字符串相加结果都是字符串</u></li>
</ul>
</li>
</ul>
<h2 id="9-显式转换"><a href="#9-显式转换" class="headerlink" title="9.显式转换"></a>9.显式转换</h2><p><strong>转换成数字型</strong></p>
<ol>
<li>Number（数据）<ul>
<li>转成数字类型</li>
<li>如果字符串内容里有非数字，转换失败时结果为NaN（Not a Number）即不是一个数字</li>
<li>NaN也是number类型的数据，代表非数字</li>
</ul>
</li>
</ol>
<p>​	2.parseInt（数据）：只保留整数</p>
<p>​	3.parseFloat（数据）：可以保留小数</p>
<h2 id="10-比较运算符"><a href="#10-比较运算符" class="headerlink" title="10.比较运算符"></a>10.比较运算符</h2><ul>
<li>&#x3D;&#x3D;&#x3D;：左右两边是否类型和值都相等</li>
<li>!&#x3D;&#x3D;：左右两边是否不全等</li>
</ul>
<p>注意：例如：2 &#x3D;&#x3D; ‘2’ ，比较运算符有隐式转换，把’2’ 转换为 2 ，只判断值；而2 &#x3D;&#x3D;&#x3D; ‘2’，输出则为false，判断 值 和 数据类型 都一样才行；NaN &#x3D;&#x3D;&#x3D; NaN，输出为false，它不等于任何人，包括他自己。</p>
<h2 id="11-操作数组"><a href="#11-操作数组" class="headerlink" title="11.操作数组"></a>11.操作数组</h2><ol>
<li>新增：可以添加一个或多个，返回的是数组长度</li>
</ol>
<ul>
<li><p>.push(元素1，…，元素n) —— 增在结尾</p>
</li>
<li><p>.unshift(元素1，…，元素n) —— 增在开头</p>
<p>2.删除</p>
</li>
<li><p>.pop()方法——从数组中删除最后一个元素，并返回该元素的值</p>
</li>
<li><p>.shift()——删除第一个元素</p>
</li>
<li><p>.splice(start, deleteCount)——删除指定元素（若只给出一个数字，则从该索引一直删到最后）</p>
<p>3.排序</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//升序</span></span><br><span class="line">.<span class="title function_">sort</span>(<span class="params"><span class="keyword">function</span>(a, b)</span>)&#123;</span><br><span class="line">	<span class="keyword">return</span> a - b</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//降序</span></span><br><span class="line">.<span class="title function_">sort</span>(<span class="params"><span class="keyword">function</span>(a, b)</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> b - a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="12-函数"><a href="#12-函数" class="headerlink" title="12.函数"></a>12.函数</h2><p>function，是被设计<strong>执行特定任务</strong>的代码块</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> 函数名(参数列表) &#123;</span><br><span class="line">	函数体</span><br><span class="line">    <span class="comment">//return 可以返回数组，类似return[max, min]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了更严谨，用户不输入实参，可以给形参默认值，可以默认为0.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">例如：</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getSum</span>(<span class="params">x = <span class="number">0</span>, y = <span class="number">0</span></span>)&#123;&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getSum</span>(<span class="params">arr = []</span>)&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>补充：</p>
<ul>
<li>两个相同的函数后面的会覆盖前面的函数</li>
<li>再JavaScript中，实参的个数和形参的个数可以不一致<ol>
<li>如果形参过多，会自动填上undefined</li>
<li>如果实参过多，那么多余的实参会被忽略（函数内部有一个argument，里面装着所有的实参）</li>
</ol>
</li>
</ul>
<blockquote>
<p>变量有一个坑，特殊情况：如果函数内部，变量没有声明，直接赋值，也当全局变量看，但是强烈不推荐，函数内部的形参可以看作是局部变量</p>
</blockquote>
<h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//语法</span></span><br><span class="line"><span class="keyword">let</span> fn = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="comment">//函数体</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line"><span class="title function_">fn</span>() <span class="comment">//函数名</span></span><br></pre></td></tr></table></figure>

<p>立即执行函数：（场景介绍：避免全局变量之间的污染）无需调用，							立即执行</p>
<ol>
<li><code>（function() &#123; console.log(11) &#125;）()</code></li>
<li><code>（function() &#123; console.log(11) &#125;()）</code></li>
</ol>
<h2 id="13-逻辑中断"><a href="#13-逻辑中断" class="headerlink" title="13.逻辑中断"></a>13.逻辑中断</h2><table>
<thead>
<tr>
<th align="center">符号</th>
<th align="center">短路条件</th>
</tr>
</thead>
<tbody><tr>
<td align="center">&amp;&amp;</td>
<td align="center">左边为false就短路，右边不执行</td>
</tr>
<tr>
<td align="center">||</td>
<td align="center">左边为true就短路，右边不执行</td>
</tr>
</tbody></table>
<p>注意：&amp;&amp; 左右都为真，返回最后一个值</p>
<h2 id="14-转换为Boolean类型"><a href="#14-转换为Boolean类型" class="headerlink" title="14.转换为Boolean类型"></a>14.转换为Boolean类型</h2><p>显示转换：</p>
<ol>
<li>Boolean（内容）：记忆：’’、0、undefined、null、false、NaN转换为布尔值后都是false，其余则为true</li>
</ol>
<h2 id="15-对象"><a href="#15-对象" class="headerlink" title="15.对象"></a>15.对象</h2><p>一种无序的数据集合，注意数组是有序的数据集合</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例如</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">	<span class="attr">uname</span>:<span class="string">&#x27;lisa&#x27;</span>, <span class="comment">//静态特征</span></span><br><span class="line">	<span class="attr">age</span>:<span class="number">18</span>, </span><br><span class="line">	<span class="attr">gender</span>:<span class="string">&#x27;女&#x27;</span>, </span><br><span class="line">    <span class="string">&#x27;goods-name&#x27;</span>:<span class="string">&#x27;小米10&#x27;</span></span><br><span class="line">	<span class="attr">sayHi</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125; <span class="comment">//动态特征</span></span><br><span class="line">&#125;</span><br><span class="line">obj.<span class="property">hobby</span> = <span class="string">&#x27;足球&#x27;</span> <span class="comment">//添加属性</span></span><br><span class="line"><span class="keyword">delete</span> obj.<span class="property">age</span> <span class="comment">//删除属性</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj[<span class="string">&#x27;goods-name&#x27;</span>]) <span class="comment">//查询的另一种方式-对象名[&#x27;属性名&#x27;]</span></span><br></pre></td></tr></table></figure>

<ol>
<li><p>语法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> 对象名 = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> 对象名 = <span class="keyword">new</span> <span class="title function_">object</span>()</span><br></pre></td></tr></table></figure></li>
</ol>
<p>​	2.遍历对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> k <span class="keyword">in</span> obj)&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(k) <span class="comment">//打印属性名</span></span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(obj[k]) <span class="comment">//打印属性值，k是自动加了&#x27;&#x27;的</span></span><br><span class="line">    <span class="comment">//console.log(obj[&#x27;uname&#x27;])</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：也可以打印数组，但是一般很少用，不推荐</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;pink&#x27;</span>, <span class="string">&#x27;yellow&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> k <span class="keyword">in</span> arr)&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(k) <span class="comment">//数组的下标 索引号 但是是字符串&#x27;0&#x27;</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(arr[k]) <span class="comment">//arr[k]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><img src="/../images/QQ%E5%9B%BE%E7%89%8720230819044724.png" alt="QQ图片20230819044724"></p>
<p>3.内置对象</p>
<ul>
<li>Math:<ul>
<li>ceil：向上取整</li>
<li>floor：向下取整</li>
<li>round：四舍五入</li>
<li>random() ：随机数</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例如:随机生成0-10的随机数</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">11</span>)</span><br><span class="line"><span class="comment">//例如:随机生成5-10的随机数</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * (<span class="number">5</span> + <span class="number">1</span>)) + <span class="number">5</span></span><br><span class="line"><span class="comment">//例如:随机生成N-M的随机数</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * (M - N + <span class="number">1</span>)) + N</span><br></pre></td></tr></table></figure>

<h2 id="16-简单和引用数据类型"><a href="#16-简单和引用数据类型" class="headerlink" title="16.简单和引用数据类型"></a>16.简单和引用数据类型</h2><ol>
<li>栈（操作系统）：由操作系统自动分配释放存放函数的参数值、局部变量的值等。其操作方式类似于数据结构中的栈；<strong>简单数据类型存放到栈里面</strong></li>
<li>堆（操作系统）：存储复杂类型（对象），一般由程序员分配释放，若程序员不释放，由垃圾回收机制回收；<strong>引用数据类型存放到堆里面</strong></li>
</ol>
<h2 id="17-循环与迭代"><a href="#17-循环与迭代" class="headerlink" title="17. 循环与迭代"></a>17. 循环与迭代</h2><p>for、do…while、while、label、break、continue、for…in、for…of</p>
<p>其中</p>
<p><strong>label</strong>：如果在嵌套的for循环中使用label，break label 和 continue label 的运行机制是不一样的，如下所示</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="attr">outPoint</span>: <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">5</span> &amp;&amp; j == <span class="number">5</span>) &#123;</span><br><span class="line">      <span class="keyword">break</span> outPoint; <span class="comment">// 在 i = 5，j = 5 时，跳出所有循环，</span></span><br><span class="line">      <span class="comment">// 返回到整个 outPoint 下方，继续执行</span></span><br><span class="line">    &#125;</span><br><span class="line">    num++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>(num); <span class="comment">// 输出 55</span></span><br></pre></td></tr></table></figure>

<p>使用 continue 语句，则可达到与未添加 label 相同的效果，但在这种有多层循环的情况下，循环的跳出进入流程更为明晰一些：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="attr">outPoint</span>: <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">5</span> &amp;&amp; j == <span class="number">5</span>) &#123;</span><br><span class="line">      <span class="keyword">continue</span> outPoint;    </span><br><span class="line">    &#125;</span><br><span class="line">    num++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">alert</span>(num); <span class="comment">// 95</span></span><br></pre></td></tr></table></figure>

<p><strong>break</strong>：</p>
<p>使用 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/break"><code>break</code></a> 语句来终止循环，<code>switch</code>，或者是链接到 label 语句。</p>
<ul>
<li>当你使用不带 label 的 <code>break</code> 时，它会立即终止当前所在的 <code>while</code>，<code>do-while</code>，<code>for</code>，或者 <code>switch</code> 并把控制权交回这些结构后面的语句。</li>
<li>当你使用带 label 的 <code>break</code> 时，它会终止指定的带标记（label）的语句。</li>
</ul>
<p><code>break</code> 语句的语法看起来像这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">break</span> [label];</span><br></pre></td></tr></table></figure>

<p>在语法中，被 <code>[]</code> 包裹的内容是可省略的，也就是 <code>label</code> 可以省略。若省略，则终止当前所在的循环或 <code>switch</code>；若不省略，则终止指定的 label 语句。</p>
<p><strong>continue</strong>：</p>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/continue"><code>continue</code></a> 语句可以用来继续执行（跳过代码块的剩余部分并进入下一循环）一个 <code>while</code>、<code>do-while</code>、<code>for</code>，或者 <code>label</code> 语句。</p>
<ul>
<li>当你使用不带 label 的 <code>continue</code> 时，它终止当前 <code>while</code>，<code>do-while</code>，或者 for 语句到结尾的这次的循环并且继续执行下一次循环。</li>
<li>当你使用带 label 的 <code>continue</code> 时，它会应用被 label 标识的循环语句。</li>
</ul>
<p><code>continue</code> 语句的语法看起来像这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">continue</span> [label];</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; <span class="number">5</span>) &#123;</span><br><span class="line">  i++;</span><br><span class="line">  <span class="keyword">if</span> (i == <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  n += i;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1,3,7,12</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; <span class="number">5</span>) &#123;</span><br><span class="line">  i++;</span><br><span class="line">  <span class="keyword">if</span> (i == <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="comment">// continue;</span></span><br><span class="line">  &#125;</span><br><span class="line">  n += i;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1,3,6,10,15</span></span><br></pre></td></tr></table></figure>

<p><strong>for…in 和 for…of 的区别</strong>：</p>
<p> <code>for...in</code> 循环遍历的结果是<strong>数组元素的下标</strong>，而 <code>for...of</code> 遍历的结果是<strong>元素的值</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>];</span><br><span class="line">arr.<span class="property">foo</span> = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> arr) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 输出 &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;foo&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 输出 &quot;3&quot;, &quot;5&quot;, &quot;7&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意 for...of 的输出没有出现 &quot;hello&quot;</span></span><br></pre></td></tr></table></figure>



<h1 id="二、APIs"><a href="#二、APIs" class="headerlink" title="二、APIs"></a>二、APIs</h1><h2 id="1-基本认知"><a href="#1-基本认知" class="headerlink" title="1.基本认知"></a>1.基本认知</h2><h3 id="1-作用和分类"><a href="#1-作用和分类" class="headerlink" title="1.作用和分类"></a>1.作用和分类</h3><ol>
<li>作用：就是使用js去操作html和浏览器</li>
<li>分类：DOM（文档对象模型）、BOM（浏览器对象模型）</li>
</ol>
<p>DOM：专门用来<strong>操作网页内容</strong>的功能（开发网页内容特效和实现用户交互）</p>
<h3 id="2-DOM树："><a href="#2-DOM树：" class="headerlink" title="2.DOM树："></a>2.DOM树：</h3><p>直观的体现了标签与标签之间的关系</p>
<p><img src="/../images/QQ%E5%9B%BE%E7%89%8720230819184438.png" alt="QQ图片20230819184438"></p>
<p>浏览器根据html标签生成的js对象</p>
<ul>
<li>所有的标签属性都可以在这个对象上面找到</li>
<li>修改这个对象的属性会自动映射到标签身上</li>
</ul>
<p>核心思想：把网页内容当作<strong>对象</strong>来处理</p>
<p>document对象：</p>
<ul>
<li>是DOM里提供的一个对象</li>
<li>提供的属性和方法都是用来访问和操作网页内容的</li>
<li>网页所有内容都在document里面</li>
</ul>
<h2 id="2-获取DOM元素"><a href="#2-获取DOM元素" class="headerlink" title="2.获取DOM元素"></a>2.获取DOM元素</h2><p> 根据css选择器来获取DOM元素</p>
<ol>
<li><p>选择匹配的第一个元素</p>
<p>语法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;css选择器&#x27;</span>)</span><br><span class="line"><span class="comment">//选择多个元素，例如选择所有的小li</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;ul li&#x27;</span>) <span class="comment">//得到的是伪数组</span></span><br><span class="line"><span class="comment">//修改，例如</span></span><br><span class="line">nav.<span class="property">style</span>.<span class="property">color</span> = <span class="string">&#x27;pink&#x27;</span></span><br></pre></td></tr></table></figure>

<p>参数：</p>
<p>包含一个或多个有效的CSS选择器<strong>字符串</strong></p>
</li>
</ol>
<h2 id="3-操作元素内容"><a href="#3-操作元素内容" class="headerlink" title="3.操作元素内容"></a>3.操作元素内容</h2><p>修改元素的文本更换内容</p>
<ol>
<li>对象.innerText 属性<ul>
<li>将文本内容添加&#x2F;更新到任意标签位置</li>
<li>显示纯文本，不解析标签</li>
</ul>
</li>
<li>对象.innerHTML 属性<ul>
<li>将文本内容添加&#x2F;更新到任意标签位置</li>
<li>会解析标签，多标签建议使用模板字符</li>
</ul>
</li>
</ol>
<h2 id="4-操作元素属性"><a href="#4-操作元素属性" class="headerlink" title="4.操作元素属性"></a>4.操作元素属性</h2><ol>
<li><p>常用<strong>属性</strong>修改</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对象.属性 = 值</span><br></pre></td></tr></table></figure>
</li>
<li><p>控制<strong>样式</strong>属性</p>
<ol>
<li><p>多组单词的采取小驼峰命名法，例如：backgroundColor</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对象.<span class="property">style</span>.属性 = 值</span><br></pre></td></tr></table></figure>
</li>
<li><p>操作类名(className)操作CSS</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">元素.<span class="property">className</span> = <span class="string">&#x27;active&#x27;</span> <span class="comment">//active 是一个css类名</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>通过classList操作类控制CSS——为了解决className容易覆盖以前的类名</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//追加一个类</span></span><br><span class="line">	元素.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&#x27;类名&#x27;</span>)</span><br><span class="line"><span class="comment">//删除一个类</span></span><br><span class="line">	元素.<span class="property">classList</span>.<span class="title function_">remove</span>(<span class="string">&#x27;类名&#x27;</span>)</span><br><span class="line"><span class="comment">//切换一个类</span></span><br><span class="line">	元素.<span class="property">classList</span>.<span class="title function_">toglle</span>(<span class="string">&#x27;类名&#x27;</span>)	</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>操作<strong>表单元素</strong>属性</p>
<p>本质是把表单类型转换为文本框</p>
<ul>
<li><p>获取：DOM对象.属性名</p>
</li>
<li><p>设置：DOM对象.属性名 &#x3D; 新值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">表单.<span class="property">value</span> = <span class="string">&#x27;用户名&#x27;</span></span><br><span class="line">表单.<span class="property">type</span> = <span class="string">&#x27;password&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>自定义属性</p>
<p>专门用data-自定义属性</p>
<p>在标签上一律以data开头</p>
<p>在DOM对象上一律以dataset对象方式获取</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span> <span class="attr">data-id</span>=<span class="string">&quot;10&quot;</span>&gt;</span>盒子<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">	<span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">const</span> box = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.box&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">		<span class="variable language_">console</span>.<span class="title function_">log</span>(box.<span class="property">dataset</span>.<span class="property">id</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>定时器-间歇函数</p>
<ol>
<li><p>开启定时器</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setInterval</span>(函数/函数名, 间隔时间)</span><br><span class="line"><span class="comment">//注意：</span></span><br><span class="line"><span class="comment">//1.函数名字不需要加括号</span></span><br><span class="line"><span class="comment">//2.定时器返回的是一个id数字</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>关闭定时器</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> 变量名 = <span class="built_in">setInterval</span>(函数/函数名, 间隔时间)</span><br><span class="line"><span class="built_in">clearInterval</span>(变量名)</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h2 id="5-事件监听"><a href="#5-事件监听" class="headerlink" title="5.事件监听"></a>5.事件监听</h2><p>目标：能够给DOM元素添加事件监听</p>
<ul>
<li><p>什么是事件</p>
<p>事件是在编程时系统内发生的动作或者发生的事情</p>
<p>比如用户在网页上单击一个按钮</p>
</li>
<li><p>什么是事件监听</p>
<p>就是让程序检测是否有事件产生，一旦有事件触发，就立即调用一个函数做出响应，也称为 绑定事件或注册事件</p>
<p>比如鼠标经过显示下拉菜单，比如点击可以播放轮播图等等</p>
</li>
<li><p>语法</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">元素对象.<span class="title function_">addEventListener</span>(<span class="string">&#x27;事件类型&#x27;</span>, 要执行的函数)</span><br></pre></td></tr></table></figure>

<ul>
<li>事件监听三要素 <ul>
<li>事件源：哪个dom元素被事件触发了，要获取dom元素</li>
<li>事件类型：用什么方式触发，比如鼠标单击click、鼠标经过mouseover等</li>
<li>事件处理程序：要做什么事</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;button&gt;按钮&lt;/button&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">const</span> btn = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.btn&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="comment">//修改元素样式</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        btn.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="title function_">alert</span>(<span class="string">&#x27;hello&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="comment">//注意：</span></span><br><span class="line"><span class="comment">//1.事件类型要加引号</span></span><br><span class="line"><span class="comment">//2.函数是点击之后再去执行，每次点击都会执行一次 </span></span><br></pre></td></tr></table></figure>

<h2 id="6-事件类型"><a href="#6-事件类型" class="headerlink" title="6.事件类型"></a>6.事件类型</h2><p> 鼠标事件（鼠标触发）：click 鼠标点击，mouseenter 鼠标经过，mouseleave 鼠标离开</p>
<p>焦点事件（表单获得光标）：focus 获得焦点，blur 失去焦点</p>
<p>键盘事件（键盘触发）：Keydown 键盘按下触发，Keyup 键盘抬起触发</p>
<p>文本事件（表单输入触发）：input 用户输入事件</p>
<h3 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h3><ol>
<li><p>是一个对象，这个对象里有事件触发时的相关信息</p>
</li>
<li><p>语法：如何获取</p>
<ul>
<li><p>在事件绑定的回调函数的第一个参数就是事件对象</p>
</li>
<li><p>一般命名为event、ev、e</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">元素.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params">e</span>) &#123;&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<p>部分常用属性：</p>
<ul>
<li>type——获取当前的事件类型</li>
<li>clientX &#x2F; clientY——获取光标相对于浏览器可见窗口左上角的位置</li>
<li>offsetX &#x2F; offsetY——获取光标相对于当前DOM元素左上角的位置</li>
<li>key——用户按下的键盘键的值（现在不提倡使用keyCode）</li>
</ul>
<p><strong>trim()</strong> :去除左右的空格</p>
<h2 id="7-环境对象"><a href="#7-环境对象" class="headerlink" title="7.环境对象"></a>7.环境对象</h2><p>指的是函数内部特殊的<strong>变量this</strong>，它代表着当前函数运行时所处的环境 </p>
<p><strong>谁调用，this就指向谁</strong></p>
<h2 id="8-回调函数"><a href="#8-回调函数" class="headerlink" title="8.回调函数"></a>8.回调函数</h2><p>把函数当作另外一个函数的参数传递</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我是回调函数...&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//fn传递给了setInterval，fn是回调函数</span></span><br><span class="line"><span class="built_in">setInterval</span>(fn, <span class="number">1000</span>)</span><br><span class="line">box.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我也是回调函数...&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-事件流"><a href="#9-事件流" class="headerlink" title="9.事件流"></a>9.事件流</h2><ol>
<li><p>事件流与两个阶段说明</p>
<ul>
<li><p>事件流指的是事件完整执行过程中的流动路径</p>
</li>
<li><p>两个阶段：捕获阶段（从外到里），冒泡阶段（从里到外）</p>
</li>
<li><p>使用冒泡为主</p>
</li>
</ul>
</li>
<li><p>事件捕获</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">DOM</span>.<span class="title function_">addEventLister</span>(事件类型, 事件处理函数, 是否使用捕获机制)</span><br></pre></td></tr></table></figure>

<ul>
<li>addEventLister第三个参数出入true代表是捕获阶段触发</li>
<li>若传入false代表冒泡触发，默认false</li>
</ul>
</li>
<li><p>事件冒泡</p>
<p>当一个元素触发事件后，会依次向上调用所有父级元素的<strong>同名事件</strong></p>
</li>
<li><p>阻止冒泡</p>
<p>把事件限制在当前元素内——阻止传播，对捕获也有效  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">事件对象.<span class="title function_">stopPropagation</span>()</span><br><span class="line"><span class="comment">//例如</span></span><br><span class="line"><span class="keyword">const</span> son = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.son&#x27;</span>)</span><br><span class="line">son.<span class="title function_">addEventLister</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&#x27;我是儿子&#x27;</span>)</span><br><span class="line">    e.<span class="title function_">stopPropagation</span>()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>解绑事件</p>
<ol>
<li>on事件方式——只有冒泡没有捕获（传统，L0）</li>
</ol>
   <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//绑定事件</span></span><br><span class="line">btn.<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&#x27;点击了&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//解绑事件</span></span><br><span class="line">btn.<span class="property">onclick</span> = <span class="literal">null</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>addEventLister方式，必须使用removeEventLister(事件类型, 事件处理函数, [获取捕获或者冒泡阶段]) （L2）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&#x27;点击了&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//绑定事件</span></span><br><span class="line">btn.<span class="title function_">addEventLister</span>(<span class="string">&#x27;click&#x27;</span>, fn)</span><br><span class="line"><span class="comment">//解绑事件</span></span><br><span class="line">btn.<span class="title function_">removeEventLister</span>(<span class="string">&#x27;click&#x27;</span>, fn)</span><br></pre></td></tr></table></figure>

<p><strong>注意：匿名函数无法被解绑</strong></p>
<pre><code>    3. **鼠标经过事件**：mouseenter和mouseleave没有冒泡效果（推荐）
</code></pre>
</li>
</ol>
</li>
</ol>
<h2 id="10-事件委托"><a href="#10-事件委托" class="headerlink" title="10.事件委托"></a>10.事件委托</h2><p>优点：减少注册次数</p>
<p>原理：利用事件冒泡的特点</p>
<ul>
<li>给<strong>父元素注册事件</strong>，当触发子元素，会冒泡到父元素身上，从而触发父元素的事件</li>
</ul>
<p>实现：事件对象.target.tagName 可以获得真正触发事件的元素</p>
<p>阻止元素默认行为：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e.<span class="title function_">preventDefault</span>()</span><br></pre></td></tr></table></figure>

<h2 id="11-其他事件"><a href="#11-其他事件" class="headerlink" title="11.其他事件"></a>11.其他事件</h2><ol>
<li><p>页面加载事件</p>
<p>加载外部资源（如图片、外联CSS和JavaScript等）加载完毕时触发的事件</p>
<p>监听页面所有资源加载完毕：</p>
<ul>
<li><p>给window添加load事件</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//页面加载事件</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;load&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="comment">//执行的操作</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<p>监听页面DOM加载完毕：</p>
<ul>
<li><p>给document添加DOMContentLoaded事件</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;DOMContentLoaded&#x27;</span>, <span class="title function_">funtion</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="comment">//执行的操作</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>元素滚动事件</p>
<p>监听整个页面滚动：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//页面滚动事件</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;scroll&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">	<span class="comment">//执行的操作</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>获取位置：</p>
<p>scrollLeft和scrollTop（属性）</p>
<ul>
<li>获取被卷去的大小</li>
<li>获取元素内容往左、往上滚出去看不到的距离</li>
<li>这两个值是可<strong>读写</strong>的</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">scrollTop</span> = <span class="number">0</span> <span class="comment">//返回顶部</span></span><br></pre></td></tr></table></figure>

<p>滚动到指定坐标：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">scrollTo</span>(x, y)</span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">scrollTo</span>(<span class="number">0</span>, <span class="number">1000</span>) <span class="comment">//让页面滚动到y轴1000像素的位置</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>页面尺寸事件</p>
<ul>
<li><p>会在窗口尺寸改变的时候触发事件：</p>
<p>resize</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;resize&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="comment">//执行的操作</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>检测屏幕宽度：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;resize&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">let</span> w = <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientWidth</span></span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(w)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<p>​	获取元素宽高：</p>
<ul>
<li>获取元素的可见部分快高（不包含边框，margin，滚动条等）</li>
<li>clientWidth和clientHeight</li>
</ul>
<h2 id="12-元素的尺寸与位置"><a href="#12-元素的尺寸与位置" class="headerlink" title="12.元素的尺寸与位置"></a>12.元素的尺寸与位置</h2><p><strong>位置：</strong></p>
<ul>
<li>获取宽度：<ul>
<li>获取元素的自身宽高、包含元素自身设置的宽高、padding、border（内容 + padding + border）</li>
<li>offsetWidth和offsetHeight</li>
<li>获取出来的是数值，方便计算</li>
<li>注意：获取的是可视宽高，如果盒子是隐藏的，获取的结果是0</li>
</ul>
</li>
<li>获取位置：<ul>
<li>offsetTop和offsetLeft<ul>
<li>带有定位的父级</li>
<li>如果都没有则以 文档左上角 为准</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>![FL]W58QRYOEUJ(02LT]5)<code>8](D:\学习\前端\js知识\FL]W58QRYOEUJ(02LT]5)</code>8.png)</p>
<p><strong>尺寸：</strong></p>
<ul>
<li><p>获取位置：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">element.<span class="title function_">getBoundingClientRect</span>()</span><br><span class="line"><span class="comment">//方法返回元素的大小及其相对于视口的位置</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="D:\学习\前端\js知识\图片\QQ图片20230827040548.png" alt="QQ图片20230827040548"></p>
<h2 id="13-日期对象"><a href="#13-日期对象" class="headerlink" title="13.日期对象"></a>13.日期对象</h2><h3 id="日期对象"><a href="#日期对象" class="headerlink" title="日期对象"></a>日期对象</h3><p>可以得到当前系统时间</p>
<ol>
<li><p>实例化</p>
<p>new关键字操作称为<strong>实例化</strong></p>
<p>创建一个事件对象并获取时间</p>
<ul>
<li><p>获得当前时间</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> date = <span class="keyword">new</span> <span class="title class_">Date</span>()</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>时间戳</p>
<p><strong>使用场景</strong>：如果计算倒计时效果，前面方法无法直接计算，需要借助于时间戳完成</p>
<p><strong>三种方式获取时间戳：</strong></p>
<ol>
<li>使用 getTime() 方法    —— 必须实例化</li>
<li>间歇 +new Date()   —— 无需实例化</li>
<li>使用Date.now()   ——无需实例化，但是只能得到当前的时间戳，而前面两种可以返回指定时间的时间戳</li>
</ol>
</li>
</ol>
<h2 id="14-节点操作"><a href="#14-节点操作" class="headerlink" title="14.节点操作"></a>14.节点操作</h2><ol>
<li><p>DOM节点<img src="D:\学习\前端\js知识\图片\QQ图片20230906211333.png" alt="QQ图片20230906211333"></p>
<p><img src="D:\学习\前端\js知识\图片\QQ图片20230906211214.png" alt="QQ图片20230906211214"></p>
</li>
<li><p>查找节点</p>
<ul>
<li><p>父节点查找：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">子元素.<span class="property">parentNode</span> <span class="comment">//返回最近一级的父节点 找不到返回null</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>子节点查找：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">父元素.<span class="property">children</span>  </span><br><span class="line"><span class="comment">//获得所有子节点、包括文本节点（空格、换行）、注释节点等</span></span><br><span class="line"><span class="comment">//仅获得所有元素节点</span></span><br><span class="line"><span class="comment">//返回的还是一个伪数组</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>增加节点</p>
<ul>
<li><p>创建节点</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;标签名&#x27;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>追加节点</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入到这个父元素的最后</span></span><br><span class="line">父元素.<span class="title function_">appendChild</span>(要插入的元素)</span><br><span class="line"><span class="comment">//插入到父元素中某个子元素的前面</span></span><br><span class="line">父元素.<span class="title function_">insertBefore</span>(要插入的元素，在哪个元素前面)</span><br></pre></td></tr></table></figure>
</li>
<li><p>克隆节点</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//克隆一个已有的元素节点</span></span><br><span class="line">元素.<span class="title function_">cloneNode</span>(布尔值)</span><br></pre></td></tr></table></figure>

<ul>
<li>若为true，则代表克隆时会包含后代节点一起克隆</li>
<li>若为false，则代表克隆时不包含后代节点</li>
<li>默认为false</li>
</ul>
</li>
</ul>
</li>
<li><p>删除节点</p>
<p>要删除元素必须通过<strong>父元素删除</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">父元素.<span class="title function_">removeChild</span>(要删除的元素)</span><br></pre></td></tr></table></figure>

<p>注：</p>
<ul>
<li>如不存在父子关系则删除不成功</li>
<li>删除节点和隐藏节点（display：none）有区别的：隐藏节点还是存在的，但是删除，则从html中删除节点</li>
</ul>
</li>
</ol>
<h2 id="15-M端事件"><a href="#15-M端事件" class="headerlink" title="15.M端事件"></a>15.M端事件</h2><p>移动端也有自己独特的地方。比如<strong>触屏事件touch</strong>（也称触摸事件），Android和IOS都有。</p>
<ul>
<li><p>常见的触屏事件如下：</p>
<p><img src="D:\学习\前端\js知识\图片\QQ图片20230907154406.png" alt="QQ图片20230907154406"></p>
</li>
</ul>
<h2 id="16-插件"><a href="#16-插件" class="headerlink" title="16.插件"></a>16.插件</h2><p><img src="D:\学习\前端\js知识\图片\QQ图片20230907160803.png" alt="QQ图片20230907160803"></p>
<h2 id="17-Window对象"><a href="#17-Window对象" class="headerlink" title="17.Window对象"></a>17.Window对象</h2><h3 id="1-BOM"><a href="#1-BOM" class="headerlink" title="1.BOM"></a>1.BOM</h3><ul>
<li>BOM时浏览器对象模型</li>
<li>window对象是一个全局对象，也可以说是javaScript中的顶级对象</li>
<li>像document、alert()、console.log()这些都是window的属性，基本BOM的属性和方法都是window的。</li>
<li>所有通过var定义在全局作用域中的变量、函数都会变成window对象的属性和方法</li>
<li>window对象下的属性和方法调用的时候可以省略window</li>
</ul>
<h3 id="2-定时器-延时函数"><a href="#2-定时器-延时函数" class="headerlink" title="2.定时器-延时函数"></a>2.定时器-延时函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(回调函数，等待的毫秒数)</span><br></pre></td></tr></table></figure>

<p>仅仅执行一次，所以可以理解为就是把一段代码延迟执行，平时省略window</p>
<p>清除延时函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> timer = <span class="built_in">setTimeout</span>(回调函数，等待的毫秒数)</span><br><span class="line"><span class="built_in">clearTimeout</span>(timer)</span><br></pre></td></tr></table></figure>

<p>注意点：</p>
<ul>
<li>延时器需要等待，所以后面的代码先执行</li>
<li>每一次调用延时器都会产生一个新的延时器</li>
</ul>
<h3 id="3-JS执行机制（同步、异步）"><a href="#3-JS执行机制（同步、异步）" class="headerlink" title="3.JS执行机制（同步、异步）"></a>3.JS执行机制（同步、异步）</h3><p><strong>同步任务：</strong></p>
<p>同步任务都在主线程上执行，形成一个<em><strong>执行线</strong></em></p>
<p><strong>异步任务：</strong></p>
<p>js的异步是通过回调函数实现的。</p>
<p>一般而言，异步任务有以下三种类型：</p>
<ol>
<li><p>普通事件，如click、resize等</p>
</li>
<li><p>资源加载，如load、error等</p>
</li>
<li><p>定时器，包括setInterval、setTimeout等</p>
<p>异步任务相关添加到<strong>任务队列</strong>中（任务队列也称为消息队列）</p>
</li>
</ol>
<p>由于主线程不断的重复获得任务、执行任务、再获取任务、再执行，所以这种机制被称为<strong>事件循环</strong></p>
<h3 id="4-location对象"><a href="#4-location对象" class="headerlink" title="4.location对象"></a>4.location对象</h3><ul>
<li><p>location的数据类型是对象，它拆分并保存了URL地址的各个组成部分</p>
</li>
<li><p>常用属性和方法：</p>
<ul>
<li><p>href属性获取完成对象的URL地址，对其赋值时用于地址的跳转</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可以得到当前文件URL地址</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(location.<span class="property">href</span>)</span><br><span class="line"><span class="comment">//可以通过js方式跳转到目标地址</span></span><br><span class="line">location.<span class="property">href</span> = <span class="string">&#x27;http://www.itcast.cn&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>search属性获取地址中携带的参数，符号 ？后面部分</p>
</li>
<li><p>hash属性获取地址中的哈希值，符号 # 后面部分</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(location.<span class="property">hash</span>)</span><br></pre></td></tr></table></figure>

<p>后期vue路由的铺垫，经常用于不刷新页面，显示不同页面，比如网易云音乐</p>
</li>
<li><p>reload方法用来刷新当前页面，传入参数true时表示强制刷新</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;button&gt;点击刷新&lt;/button&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"> <span class="keyword">let</span> btn = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;button&#x27;</span>)    btn.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">     location.<span class="title function_">reload</span>(<span class="literal">true</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">     <span class="comment">//强制刷新，类似ctrl + f5</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"> &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="5-navigator对象"><a href="#5-navigator对象" class="headerlink" title="5.navigator对象"></a>5.navigator对象</h3><p>数据类型是对象，该对象记录下浏览器自身的相关信息</p>
<p>常用属性和方法：</p>
<p>通过userAgent检测浏览器的版本及平台</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检测 userAgent（浏览器信息）</span></span><br><span class="line">(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> userAgent = navigator.<span class="property">userAgent</span></span><br><span class="line">  <span class="comment">// 验证是否为Android或iPhone</span></span><br><span class="line">  <span class="keyword">const</span> android = userAgent.<span class="title function_">match</span>(<span class="regexp">/(Android);?[\s\/]+([\d.]+)?/</span>)</span><br><span class="line">  <span class="keyword">const</span> iphone = userAgent.<span class="title function_">match</span>(<span class="regexp">/(iPhone\sOS)\s([\d_]+)/</span>)</span><br><span class="line">  <span class="comment">// 如果是Android或iPhone，则跳转至移动站点</span></span><br><span class="line">  <span class="keyword">if</span> (android || iphone) &#123;</span><br><span class="line">    location.<span class="property">href</span> = <span class="string">&#x27;http://m.itcast.cn&#x27;</span></span><br><span class="line">  &#125;&#125;)();</span><br></pre></td></tr></table></figure>

<h3 id="6-histroy对象"><a href="#6-histroy对象" class="headerlink" title="6.histroy对象"></a>6.histroy对象</h3><ul>
<li><p>history的数据类型是对象，主要管理历史记录，该对象与浏览器地址栏的操作相对应，如前进、后退、历史记录等</p>
</li>
<li><p>常用属性和方法：</p>
<table>
<thead>
<tr>
<th>history对象方法</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td>back（）</td>
<td align="left">可以后退功能</td>
</tr>
<tr>
<td>forward（）</td>
<td align="left">前进功能</td>
</tr>
<tr>
<td>go（参数）</td>
<td align="left">前进后退功能 参数如果是1前进1个页面，如果是-1 后退1个页面</td>
</tr>
</tbody></table>
</li>
</ul>
<h2 id="18-本地存储"><a href="#18-本地存储" class="headerlink" title="18.本地存储"></a>18.本地存储</h2><h3 id="1-本地存储介绍"><a href="#1-本地存储介绍" class="headerlink" title="1.本地存储介绍"></a>1.本地存储介绍</h3><ul>
<li>数据存储再用户浏览器钟</li>
<li>设置、读取方便、甚至页面刷新不丢失数据</li>
<li>容量较大，sessionStorage和localStorage越5M左右</li>
</ul>
<h3 id="2-本地存储分类"><a href="#2-本地存储分类" class="headerlink" title="2.本地存储分类"></a>2.本地存储分类</h3><p><strong>localStorage：</strong></p>
<p><a href=""><em>本地存储只能存储字符串数据类型</em></a></p>
<ul>
<li><p><strong>作用</strong>：可以将数据永久存储再本地（用户的电脑），除非手动删除，否则关闭页面也会存在</p>
</li>
<li><p><strong>特性</strong>：</p>
<ul>
<li>可以多窗口（页面）共享（同一浏览器可以共享）</li>
<li>以键值对的形式存储使用</li>
</ul>
</li>
<li><p><strong>语法</strong>：</p>
<ul>
<li><p>存储数据：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(key, value)</span><br><span class="line"><span class="comment">//例如：</span></span><br><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&#x27;umane&#x27;</span>, <span class="string">&#x27;小明&#x27;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取数据：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(key)</span><br><span class="line"><span class="comment">//例如：</span></span><br><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;uname&#x27;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除数据：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">removeItem</span>(key)</span><br><span class="line"><span class="comment">//例如：</span></span><br><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">removeItem</span>(<span class="string">&#x27;uname&#x27;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>改数据：如果原来有这个键，则是改，如果没有这个键就是增</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&#x27;uname&#x27;</span>, <span class="string">&#x27;小红&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p><strong>sessionStorage：</strong></p>
<ul>
<li><strong>特性</strong>：<ul>
<li>生命周期为关闭浏览器窗口</li>
<li>在同一个窗口（页面）下数据可以共享</li>
<li>以键值对的形式存储使用</li>
<li>用法跟localStorage基本相同</li>
</ul>
</li>
</ul>
<h3 id="3-存储复杂数据类型"><a href="#3-存储复杂数据类型" class="headerlink" title="3.存储复杂数据类型"></a>3.存储复杂数据类型</h3><p>存储复杂数据类型是无法直接使用的，只能存储字符串</p>
<ul>
<li><p>解决：需要将复杂数据类型转换成JSON字符串，在存储到本地</p>
</li>
<li><p>语法：JSON.stringify(复杂数据类型)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&#x27;obj&#x27;</span>, <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj))</span><br></pre></td></tr></table></figure>
</li>
<li><p>把JSON字符串转换成 对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;obj&#x27;</span>)))</span><br><span class="line"><span class="comment">//或者是如下</span></span><br><span class="line"><span class="keyword">const</span> str = <span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;obj&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">JSON</span>.<span class="title function_">parse</span>(str))</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="19-字符串拼接新思路"><a href="#19-字符串拼接新思路" class="headerlink" title="19.字符串拼接新思路"></a>19.字符串拼接新思路</h2><p>效果更高，<strong>开发常用</strong>的写法</p>
<ul>
<li><p>利用map() 和 join() 数组方法实现字符串拼接</p>
</li>
<li><p>数组中map方法 迭代数组</p>
<ul>
<li><p>使用场景：</p>
<p>map可以遍历数组<strong>处理数据</strong>，并且<strong>返回新的数组</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;green&#x27;</span>]</span><br><span class="line"><span class="keyword">const</span> newArr = arr.<span class="title function_">map</span>(<span class="keyword">function</span>(<span class="params">ele, index</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(ele);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(index);</span><br><span class="line">    <span class="keyword">return</span> ele + <span class="string">&#x27;颜色&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newArr)</span><br></pre></td></tr></table></figure>

<p><img src="D:\学习\前端\js知识\图片\QQ图片20230909204305.png" alt="QQ图片20230909204305"></p>
<p><strong>map也称映射</strong>。映射是个术语，指两个元素的集之间元素相互“对应”的关系。</p>
<p><strong>map重点在于有返回值</strong>，forEach没有返回值</p>
</li>
</ul>
</li>
<li><p>数组中的join方法</p>
<ul>
<li><p>作用：</p>
<p>join() 方法用于把数组中的所有元素<strong>转换一个字符串</strong></p>
</li>
<li><p>语法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">&#x27;red颜色&#x27;</span>,<span class="string">&#x27;blue颜色&#x27;</span>, <span class="string">&#x27;green颜色&#x27;</span>]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>)) </span><br><span class="line"><span class="comment">//red颜色blue颜色green颜色</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>数组中map + join 方法渲染页面思路：</p>
<p>map遍历数组<strong>处理数据</strong>生成tr，返回一个<strong>数组</strong>，然后用 join方法 把数组转换成字符串，渲染给tbody</p>
</li>
</ul>
<h2 id="20-正则表达式"><a href="#20-正则表达式" class="headerlink" title="20.正则表达式"></a>20.正则表达式</h2><ol>
<li><p>介绍</p>
<ul>
<li>正则表达式是用于匹配字符串中字符组合的模式。在JavaScript中，正则表达式也是对象</li>
<li>通常用来<strong>查找</strong>、<strong>替换</strong>那些符合正则表达式的文本，许多语言都支持正则表达式（比如说：表单验证【匹配】、过滤敏感词【替换】、字符串中提取我们想要的部分【提取】）</li>
</ul>
</li>
<li><p>语法</p>
<p>定义正则表达式语法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> 变量名 = <span class="regexp">/表达式/</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>判断是否有符合规则的字符串：</p>
<p>test() 方法  用来查看正则表达式与指定的字符串是否匹配</p>
<p>如果匹配成功返回true，否则返回false</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">regObj.<span class="title function_">test</span>(被检测的字符串)</span><br><span class="line"><span class="comment">//例如</span></span><br><span class="line"><span class="keyword">const</span> str = <span class="string">&#x27;学前端一家人&#x27;</span></span><br><span class="line"><span class="keyword">const</span> reg = <span class="regexp">/前端/</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(reg.<span class="title function_">test</span>(str))</span><br></pre></td></tr></table></figure>

<ul>
<li><p>检索（查找）符合规则的字符串：</p>
<p>exec()  方法  在一个指定字符串中执行一个搜索匹配</p>
<p>如果匹配成功返回一个数组，否则返回null</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">regObj.<span class="title function_">exec</span>(被检测字符串)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>元字符（特殊字符）</p>
<p>是一些具有特殊含义的字符，可以极大提高灵活性和强大的匹配功能。</p>
<p>比如：规定用户只能输入英文26个英文字母，普通字符的话abcdefgh…</p>
<p>​			但是换成元字符写法：[a - z]</p>
<ul>
<li><p>边界符（表示位置，开头和结尾，必须用什么开头，用什么结尾）</p>
<p><strong>用来提示字符所在的位置</strong>，主要有两个字符</p>
<table>
<thead>
<tr>
<th>边界符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>^</td>
<td>表示匹配行首的文本（以谁开始）</td>
</tr>
<tr>
<td>$</td>
<td>表示匹配行尾的文本（以谁结束）</td>
</tr>
</tbody></table>
</li>
<li><p>量词（表示重复次数）</p>
<p>用来<strong>设置某个模式出现的次数</strong></p>
<table>
<thead>
<tr>
<th>量词</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>*</td>
<td>重复零次或更多次</td>
</tr>
<tr>
<td>+</td>
<td>重复一次或更多次</td>
</tr>
<tr>
<td>？</td>
<td>重复零次或一次</td>
</tr>
<tr>
<td>{n}</td>
<td>重复n次</td>
</tr>
<tr>
<td>{n,}</td>
<td>重复n次或更多次</td>
</tr>
<tr>
<td>{n,m}</td>
<td>重复n到m次</td>
</tr>
</tbody></table>
</li>
<li><p>字符类（比如 \d 表示0~9）</p>
<p>（1）[ ] 里面加上 - 连字符</p>
<ul>
<li><p>使用连字符 - 表示一个范围</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="regexp">/^[a-z]$/</span>.<span class="title function_">test</span>(<span class="string">&#x27;c&#x27;</span>)) <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>比如：</p>
<ul>
<li>[a-z] 表示 a到z 26个英文字母都可以</li>
<li>[a - zA - Z] 表示大小都可以</li>
<li>[ 0 - 9]  表示0~9的数字都可以</li>
</ul>
</li>
</ul>
<p>（4）[ abc ] 表示选择abc中的一个</p>
<p>（3）[ ] 里面加上 ^ 取反符号</p>
<p>​	比如：</p>
<ul>
<li>[^a - z] 匹配除了小写字母以外的字符</li>
<li><strong>注意要写到中括号里面</strong></li>
</ul>
<p>（4）. 匹配除换行符之外的任何单个字符</p>
<p>（5）预定义：指的是某些常见模式的简写方式</p>
<p><img src="D:\学习\前端\js知识\图片\QQ图片20230912204003.png" alt="QQ图片20230912204003"></p>
<p><strong>日期格式：^\d{4}-\d{1,2}-\d{1,2}</strong></p>
</li>
</ul>
</li>
<li><p>修饰符</p>
<ul>
<li><p>修饰符约束正则执行的某些细节行为，如是否区分大小写、是否支持多行匹配等</p>
</li>
<li><p>语法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/表达式/修饰符</span><br></pre></td></tr></table></figure>

<ul>
<li>i 是单词 ignore 的缩写，正则匹配时字母不区分大小写</li>
<li>g 是单词 global 的缩写，匹配所有满足正则表达式的结果</li>
</ul>
</li>
</ul>
</li>
</ol>
<ul>
<li><p>​	替换 replace 替换</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">字符串.replace(/正则表达式/,&#x27;替换的文本&#x27;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="21-索引集合类"><a href="#21-索引集合类" class="headerlink" title="21. 索引集合类"></a>21. 索引集合类</h2><h3 id="数组方法："><a href="#数组方法：" class="headerlink" title="数组方法："></a>数组方法：</h3><ol>
<li><p>Array对象具有下列方法：</p>
<ul>
<li><p>concat() 拼接数组</p>
</li>
<li><p>join() 拼接元素成字符串</p>
</li>
<li><p>push()</p>
</li>
<li><p>pop()</p>
</li>
<li><p>shift() 移除第一个元素</p>
</li>
<li><p>unshift() 添加一个或多个元素到开头</p>
</li>
<li><p>slice() 方法从数组提取一个片段，并作为一个新数组返回。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myArray = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>, <span class="string">&quot;e&quot;</span>];</span><br><span class="line">myArray = myArray.<span class="title function_">slice</span>(<span class="number">1</span>, <span class="number">4</span>); <span class="comment">// [ &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]</span></span><br><span class="line"><span class="comment">// 从索引 1 开始，提取所有的元素，直到索引 3 为止</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>at() 方法返回数组中指定索引处的元素，如果索引超出范围，则返回 <code>undefined</code>。它主要用于从数组末尾访问元素的负下标。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myArray = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>, <span class="string">&quot;e&quot;</span>];</span><br><span class="line">myArray.<span class="title function_">at</span>(-<span class="number">2</span>); <span class="comment">// &quot;d&quot;，myArray 的倒数第二个元素</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>splice() 方法从数组移除一些元素，并（可选地）替换它们。它返回从数组中删除的元素。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myArray = [<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>, <span class="string">&quot;4&quot;</span>, <span class="string">&quot;5&quot;</span>];</span><br><span class="line">myArray.<span class="title function_">splice</span>(<span class="number">1</span>, <span class="number">3</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>);</span><br><span class="line"><span class="comment">// myArray 现在是 [&quot;1&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;5&quot;]</span></span><br><span class="line"><span class="comment">// 本代码从 1 号索引开始（或元素“2”所在的位置），</span></span><br><span class="line"><span class="comment">// 移除 3 个元素，然后将后续元素插入到那个位置上。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>reverse() 颠倒数组</p>
</li>
<li><p>flat() 拍平数组</p>
</li>
<li><p>sort()</p>
</li>
<li><p>indexOf() 方法在数组中搜索 <code>searchElement</code> 并返回第一个匹配的索引。</p>
</li>
<li><p>lastIndexOf() 方法的工作原理类似于 <code>indexOf</code>，但这是从末尾开始，反向搜索。</p>
</li>
<li><p>forEach() </p>
</li>
<li><p>map()</p>
</li>
<li><p>faltMap() 方法先执行 <code>map()</code>，再执行深度为 1 的 <code>flat()</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a1 = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>];</span><br><span class="line"><span class="keyword">const</span> a2 = a1.<span class="title function_">flatMap</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> [item.<span class="title function_">toUpperCase</span>(), item.<span class="title function_">toLowerCase</span>()]);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a2); <span class="comment">// [&#x27;A&#x27;, &#x27;a&#x27;, &#x27;B&#x27;, &#x27;b&#x27;, &#x27;C&#x27;, &#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>filter() 方法返回一个新数组，其中包含 <code>callback</code> 返回 <code>true</code> 的元素。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a1 = [<span class="string">&quot;a&quot;</span>, <span class="number">10</span>, <span class="string">&quot;b&quot;</span>, <span class="number">20</span>, <span class="string">&quot;c&quot;</span>, <span class="number">30</span>];</span><br><span class="line"><span class="keyword">const</span> a2 = a1.<span class="title function_">filter</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> <span class="keyword">typeof</span> item === <span class="string">&quot;number&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a2); <span class="comment">// [10, 20, 30]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>find() 方法返回 <code>callback</code> 返回 <code>true</code> 的第一个元素。</p>
</li>
<li><p>findLast() 方法返回 <code>callback</code> 返回 <code>true</code> 的最后一个元素。</p>
</li>
<li><p>findIndex() 方法返回 <code>callback</code> 返回 <code>true</code> 的第一个元素的索引。</p>
</li>
<li><p>findLastIndex() 方法返回 <code>callback</code> 返回 <code>true</code> 的最后一个元素的索引。</p>
</li>
<li><p>reduce() 方法对数组中的每个值执行 <code>callback(accumulator, currentValue, currentIndex, Array)</code>，目的是将列表中的元素减少到单个值。<code>reduce</code> 函数返回 <code>callback</code> 函数返回的最终值。</p>
<p>如果指定了 <code>initialValue</code>，则调用 <code>callback</code>，并将 <code>initialValue</code> 作为第一个参数值，将数组中第一个元素的值作为第二个参数值。</p>
<p>如果<em>没有</em>指定 <code>initialValue</code>，那么 <code>callback</code> 的前两个参数值将是数组的第一个和第二个元素。之后的<em>每一次</em>调用，第一个参数的值将是前一个调用中返回的 <code>callback</code>，第二个参数的值将是数组中的下一个值。</p>
<p>如果 <code>callback</code> 需要访问正在处理的元素的索引，或者访问整个数组，它们可以作为可选参数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>];</span><br><span class="line"><span class="keyword">const</span> total = a.<span class="title function_">reduce</span>(</span><br><span class="line">  <span class="function">(<span class="params">accumulator, currentValue</span>) =&gt;</span> accumulator + currentValue,</span><br><span class="line">  <span class="number">0</span>,</span><br><span class="line">);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(total); <span class="comment">// 60</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>reducRight() 方法的工作原理类似于 <code>reduce()</code>，但从最后一个元素开始。</p>
<p><code>reduce</code> 和 <code>reduceRight</code> 是迭代数组方法中最不被人熟知的两个函数。它们应该使用在那些需要把数组的元素两两递归处理，并最终计算成一个单一结果的算法。</p>
</li>
</ul>
</li>
</ol>
<h1 id="三、js进阶"><a href="#三、js进阶" class="headerlink" title="三、js进阶"></a>三、js进阶</h1><h2 id="1-作用域"><a href="#1-作用域" class="headerlink" title="1.作用域"></a>1.作用域</h2><h3 id="1-1-局部作用域"><a href="#1-1-局部作用域" class="headerlink" title="1.1 局部作用域"></a>1.1 局部作用域</h3><p>局部作用域分为<strong>函数作用域</strong>和<strong>块作用域</strong></p>
<p>函数作用域：略</p>
<p>块作用域：在JavaScript中使用 {} 包裹的代码称为代码块 </p>
<h3 id="1-2-全局-作用域"><a href="#1-2-全局-作用域" class="headerlink" title="1.2 全局 作用域"></a>1.2 全局 作用域</h3><p>略</p>
<h3 id="1-3-作用域链"><a href="#1-3-作用域链" class="headerlink" title="1.3 作用域链"></a>1.3 作用域链</h3><p>本质上是最底层的<strong>变量查找机制</strong></p>
<ul>
<li>在函数被执行时，会<strong>优先查找当前</strong>函数作用域中查找变量</li>
<li>如果当前作用域查找不到则会一次<strong>逐级查找父级作用域</strong>直到全局作用域</li>
</ul>
<h3 id="1-4-垃圾回收机制"><a href="#1-4-垃圾回收机制" class="headerlink" title="1.4 垃圾回收机制"></a>1.4 垃圾回收机制</h3><p>垃圾回收机制简称GC</p>
<p>js中<strong>内存</strong>的分配和回收都是<strong>自动完成</strong>的，内存在不使用的时候会被<strong>垃圾回收器</strong>自动回收</p>
<p>内存泄漏：程序中分配的<strong>内存</strong>由于某种原因程序<strong>未释放</strong>或<strong>无法释放</strong>叫做<strong>内存泄漏</strong></p>
<h3 id="1-5-闭包"><a href="#1-5-闭包" class="headerlink" title="1.5 闭包"></a>1.5 闭包</h3><p>概念：一个函数对周围状态的引用捆绑在一起，内层函数中访问到其外层函数的作用域（可能会引起内存泄漏）</p>
<p>简单理解：<strong>闭包 &#x3D; 内层函数 + 外层函数的变量</strong></p>
<p>闭包作用：封闭数据，提供操作，外部也可以访问函数内部的变量</p>
<p>基本格式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">outer</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">10</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">    	<span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fn</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> fun = <span class="title function_">outer</span>()</span><br><span class="line"><span class="title function_">fun</span>()</span><br></pre></td></tr></table></figure>

<h3 id="1-6-变量提升"><a href="#1-6-变量提升" class="headerlink" title="1.6 变量提升"></a>1.6 变量提升</h3><p>是JavaScript中比较“奇怪”的现象，它允许在变量声明之前被访问（仅存在于var声明变量）</p>
<p>注意：</p>
<ol>
<li>变量在未声明即被访问时会报语法错误</li>
<li>变量在var声明之前即被访问，变量的值为undefined</li>
<li>let&#x2F;const 声明的变量不存在变量提示</li>
<li>变量提升出现在相同作用域当中</li>
<li>实际开发中推荐先声明再访问变量</li>
</ol>
<h3 id="1-7-使用-arguments-对象"><a href="#1-7-使用-arguments-对象" class="headerlink" title="1.7 使用 arguments 对象"></a>1.7 使用 arguments 对象</h3><p>函数的实际参数会被保存在一个类似数组的 arguments 对象中。在函数内，你可以按如下方式找出传入的参数：</p>
<p>JSCopy to Clipboard</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arguments[i];</span><br></pre></td></tr></table></figure>

<p>其中 <code>i</code> 是参数的序号，从 <code>0</code> 开始。所以第一个传入函数的参数会是 <code>arguments[0]</code>。参数的数量由 <code>arguments.length</code> 表示。</p>
<p>使用 <code>arguments</code> 对象，你可以处理比声明更多的参数来调用函数。这在你事先不知道会需要将多少参数传递给函数时十分有用。你可以用 <code>arguments.length</code> 来获得实际传递给函数的参数的数量，然后用 <code>arguments</code> 对象来访问每个参数。</p>
<p>例如，考虑有一个用来连接字符串的函数。唯一正式的参数是在连接后的字符串中用来分隔各个连接部分的字符。该函数定义如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myConcat</span>(<span class="params">separator</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="string">&quot;&quot;</span>; <span class="comment">// 初始化列表</span></span><br><span class="line">  <span class="comment">// 迭代 arguments</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="variable language_">arguments</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    result += <span class="variable language_">arguments</span>[i] + separator;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可以给这个函数传递任意数量的参数，它会将各个参数连接成一个字符串“列表”：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">myConcat</span>(<span class="string">&quot;、&quot;</span>, <span class="string">&quot;红&quot;</span>, <span class="string">&quot;橙&quot;</span>, <span class="string">&quot;蓝&quot;</span>));</span><br><span class="line"><span class="comment">// &quot;红、橙、蓝、&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">myConcat</span>(<span class="string">&quot;；&quot;</span>, <span class="string">&quot;大象&quot;</span>, <span class="string">&quot;长颈鹿&quot;</span>, <span class="string">&quot;狮子&quot;</span>, <span class="string">&quot;猎豹&quot;</span>));</span><br><span class="line"><span class="comment">// &quot;大象；长颈鹿；狮子；猎豹；&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">myConcat</span>(<span class="string">&quot;。&quot;</span>, <span class="string">&quot;智者&quot;</span>, <span class="string">&quot;罗勒&quot;</span>, <span class="string">&quot;牛至&quot;</span>, <span class="string">&quot;胡椒&quot;</span>, <span class="string">&quot;香菜&quot;</span>));</span><br><span class="line"><span class="comment">// &quot;智者。罗勒。牛至。胡椒。香菜。&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="2-函数进阶"><a href="#2-函数进阶" class="headerlink" title="2.函数进阶"></a>2.函数进阶</h2><h3 id="2-1-函数提升"><a href="#2-1-函数提升" class="headerlink" title="2.1 函数提升"></a>2.1 函数提升</h3><p>与变量提升类似，是指函数在声明之前即可被调用</p>
<ol>
<li>函数提升能够使函数声明调用更灵活</li>
<li><strong>函数表达式不存在提升现象</strong></li>
<li>出现在相同作用域当中</li>
</ol>
<h3 id="2-2-函数参数"><a href="#2-2-函数参数" class="headerlink" title="2.2 函数参数"></a>2.2 函数参数</h3><p>1.动态参数</p>
<p><strong>arguments</strong> 是函数内部内置的伪数组变量，它包含了调用函数时传入的所有实参</p>
<ol>
<li><strong>arguments</strong> 是一个<strong>伪数组</strong>，只存在于函数中</li>
<li>arguments 的作用是动态获取函数的实参</li>
<li>可以通过for循环依次得到传递过来的实参</li>
</ol>
<p>2.剩余参数</p>
<p>允许我们将一个不定数量的参数表示为一个数组</p>
<ol>
<li>…是语法符号，置于最末函数形参之前，用于获取<strong>多余</strong>的实参</li>
<li>借助…获取的剩余实参，是个<strong>真数组</strong></li>
<li>开发中，还是提倡多使用<strong>剩余参数</strong></li>
</ol>
<p><strong>展开运算符</strong></p>
<p>（…）为展开运算符，将一个数组进行展开</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">5</span>]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(...arr)  <span class="comment">//1 5 3 8 5</span></span><br></pre></td></tr></table></figure>

<ol>
<li>不会修改原数组 </li>
<li>使用场景：求数组中的最大值或最小值，合并数组等</li>
</ol>
<p><strong>展开运算符 or 剩余参数</strong></p>
<p>剩余参数：函数参数使用，得到真数组</p>
<p>展开运算符：数组中使用，数组展开</p>
<h3 id="2-3-箭头函数（重要）"><a href="#2-3-箭头函数（重要）" class="headerlink" title="2.3 箭头函数（重要）"></a>2.3 箭头函数（重要）</h3><p><strong>目的</strong>：引入箭头函数的目的是更简短的函数写法并且不绑定this，箭头函数的语法比函数表达式更简洁</p>
<p><strong>使用场景</strong>：箭头函数更适用于那些本来<strong>需要匿名函数的地方</strong> </p>
<p><strong>语法</strong>：</p>
<ul>
<li>如果函数体只有一行代码，可以写到一行上，并且无需写return直接返回值</li>
<li>箭头函数可以直接返回一个对象</li>
</ul>
<p><strong>箭头函数参数：</strong></p>
<ol>
<li>普通函数有arguments动态参数</li>
<li><strong>箭头函数</strong>没有arguments动态参数，但是有  <strong>剩余参数</strong> …args</li>
</ol>
<p>箭头函数this：</p>
<p>在箭头函数出现之前，每一个新函数根据它是被如何调用的来定义这个函数的this值。<strong>箭头函数不会常见自己的this</strong>，它只会从自己的作用域链上一层沿用this。</p>
<h2 id="3-解构赋值"><a href="#3-解构赋值" class="headerlink" title="3.解构赋值"></a>3.解构赋值</h2><h3 id="3-1-数组解构"><a href="#3-1-数组解构" class="headerlink" title="3.1 数组解构"></a>3.1 数组解构</h3><p>数组解构是将数组的单元值快速批量赋值给一系列变量的简介语法</p>
<p><strong>基本语法：</strong></p>
<ol>
<li>赋值基本运算符 &#x3D; 左侧的 [ ] 用于批量声明变量，右侧数组的单元值将被赋值给左侧的变量</li>
<li>变量的顺序对应数组单元值的位置依次进行赋值操作</li>
</ol>
<blockquote>
<p>注意：js前面必须加分号的情况</p>
<ol>
<li><p>立即执行函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span> <span class="title function_">t</span>(<span class="params"></span>) &#123;&#125;) ();</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line">;(<span class="keyword">function</span> <span class="title function_">t</span>(<span class="params"></span>) &#123;&#125;) ()</span><br></pre></td></tr></table></figure>
</li>
<li><p>数组解构</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组开头的，特别是前面有语句的一定注意加分号</span></span><br><span class="line">;[b, a] = [a, b]</span><br></pre></td></tr></table></figure></li>
</ol>
</blockquote>
<p>防止有undefined传递单元值的情况，可以设置默认值：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [a = <span class="number">0</span>, b = <span class="number">0</span>] = [<span class="number">1</span>, <span class="number">2</span>]</span><br></pre></td></tr></table></figure>

<p>按需导入，忽略某些返回值：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [a, , c, d] = [<span class="string">&#x27;小米&#x27;</span>, <span class="string">&#x27;苹果&#x27;</span>, <span class="string">&#x27;华为&#x27;</span>, <span class="string">&#x27;格力&#x27;</span>]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a)  <span class="comment">//小米</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c)  <span class="comment">//华为</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(d)  <span class="comment">//格力</span></span><br></pre></td></tr></table></figure>

<h3 id="3-2-对象解构"><a href="#3-2-对象解构" class="headerlink" title="3.2 对象解构"></a>3.2 对象解构</h3><p>对象解构是将对象属性和方法快速批量赋值给一系列变量的简洁语法</p>
<ol>
<li>基本语法<ol>
<li>赋值运算符 &#x3D; 左侧的 { } 用于批量声明变量，右侧对象的属性值将赋值给左侧的变量</li>
<li>对象属性的值将被赋值给与属性名相同的变量</li>
<li>注意解构的变量名不要和外面的变量名冲突否则报错</li>
<li>对象中找不到与变量名一致的属性时变量值为undefined</li>
</ol>
</li>
<li>多级对象解构</li>
</ol>
<p><strong>遍历数组forEach方法（重点）</strong></p>
<ul>
<li><p>forEach() 方法用于调用数组的每个元素，并将元素传递给回调函数</p>
</li>
<li><p>主要使用场景：遍历数组的每个元素</p>
</li>
<li><p>语法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">被遍历的数组.<span class="title function_">forEach</span>(<span class="params"><span class="keyword">function</span>(当前数组元素, 当前元素索引号)</span>) &#123;</span><br><span class="line">	<span class="comment">//函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ol>
<li>forEach 主要是遍历数组</li>
<li>参数当前数组元素是必须要写的，索引号可选</li>
</ol>
</li>
</ul>
<p><strong>筛选数组 filter 方法（重点）</strong> </p>
<ul>
<li><p>filter() 方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素</p>
</li>
<li><p>主要使用场景：筛选数组符合条件的元素，并返回筛选之后元素的新数组</p>
</li>
<li><p>语法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">被遍历的数组.<span class="title function_">filter</span>(<span class="keyword">function</span>(<span class="params">currentValue, index</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> 筛选条件</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//筛选数组中大于30的元素</span></span><br><span class="line"><span class="keyword">const</span> score = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">3</span>, <span class="number">40</span>, <span class="number">33</span>]</span><br><span class="line"><span class="keyword">const</span> re = score.<span class="title function_">filter</span>(<span class="keyword">function</span> (<span class="params">item</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> item &gt; <span class="number">30</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(re) <span class="comment">//[50, 40, 33]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>返回值：返回数组，包含了符合条件的所有元素。如果没有符合条件的元素则返回空数组</p>
</li>
<li><p>参数：currentValue 必须写，index可选</p>
</li>
<li><p>因为返回新数组，所以不会影响原数组</p>
</li>
</ul>
<h2 id="4-深入对象"><a href="#4-深入对象" class="headerlink" title="4.深入对象"></a>4.深入对象</h2><h3 id="4-1-创建对象的三种方式"><a href="#4-1-创建对象的三种方式" class="headerlink" title="4.1 创建对象的三种方式"></a>4.1 创建对象的三种方式</h3><ol>
<li><p>利用对象字面量创建对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> o = &#123;</span><br><span class="line">	<span class="attr">name</span>: <span class="string">&#x27;佩奇&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>利用new Object 创建对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> o = <span class="keyword">new</span> <span class="title class_">Object</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;佩奇&#x27;</span> &#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(o)  <span class="comment">//&#123;name: &#x27;佩奇&#x27;&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>利用构造函数创建对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">   </span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="4-2-构造函数"><a href="#4-2-构造函数" class="headerlink" title="4.2 构造函数"></a>4.2 构造函数</h3><ul>
<li>构造函数：是一种特殊的函数，主要用来初始化对象</li>
<li>使用场景：常规的 {…} 语法允许创建一个对象。比如我们创建了佩奇的对象，继续创建乔治还需要重新写一遍，此时可以通过<strong>构造函数</strong>来<strong>快速创建多个类似的对象</strong></li>
</ul>
<p>静态成员：</p>
<ul>
<li><strong>构造函数的</strong>属性和方法称为静态成员</li>
<li>静态成员只能构造函数访问</li>
</ul>
<p><img src="/../images/image-20231001190108269.png" alt="image-20231001190108269"></p>
<h2 id="5-内置构造函数"><a href="#5-内置构造函数" class="headerlink" title="5.内置构造函数"></a>5.内置构造函数</h2><p>引用数据类型：Object，Array，RegExp，Date等</p>
<ol>
<li><p>Object</p>
<ul>
<li><p>Object.keys 静态方法获取对象中所有属性（键）</p>
</li>
<li><p>Object.values 静态方法获取对象中所有值（值）</p>
</li>
<li><p>Object.assign 静态方法常用于对象拷贝</p>
<p>经常使用的场景是给对象添加属性</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> o = &#123;<span class="attr">name</span>:<span class="string">&#x27;佩奇&#x27;</span>, <span class="attr">age</span>:<span class="number">6</span> &#125;</span><br><span class="line"><span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(obj, o)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj)</span><br><span class="line"></span><br><span class="line"><span class="comment">//给 o 新增属性</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(o, &#123;<span class="attr">gender</span>:<span class="string">&#x27;女&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure>


</li>
<li><p>返回的是一个数组</p>
</li>
</ul>
</li>
<li><p>Array</p>
<p><img src="/../images/image-20231001202007651.png" alt="image-20231001202007651"></p>
<p>作用：<strong>reduce</strong> 返回<strong>累计处理的结果</strong>，经常用于<strong>求和等</strong></p>
<p>基本语法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">arr.<span class="title function_">reduce</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;, 起始值)</span><br><span class="line">arr.<span class="title function_">reduce</span>(<span class="keyword">function</span>(<span class="params">上一次值, 当前值</span>) &#123;&#125;, 起始值)</span><br><span class="line"></span><br><span class="line"><span class="comment">//例如</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">8</span>]</span><br><span class="line"><span class="comment">//1.没有初始值</span></span><br><span class="line"><span class="keyword">const</span> total1 = arr.<span class="title function_">reduce</span>(<span class="keyword">function</span>(<span class="params">prev, current</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> prev + current</span><br><span class="line">&#125;) </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(total1);</span><br><span class="line"><span class="comment">//2.没有初始值</span></span><br><span class="line"><span class="keyword">const</span> total2 = arr.<span class="title function_">reduce</span>(<span class="keyword">function</span>(<span class="params">prev, current</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> prev + current</span><br><span class="line">&#125;, <span class="number">10</span>) </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(total2);</span><br></pre></td></tr></table></figure>

<p><img src="/../images/image-20231001203733710.png" alt="image-20231001203733710"></p>
</li>
<li><p>String</p>
<p><img src="/../images/image-20231007215007826.png" alt="image-20231007215007826"></p>
</li>
<li><p>Number</p>
<p>常用方法：</p>
<p>toFixed() 设置保留小数位的长度</p>
</li>
</ol>
<h2 id="6-编程思想"><a href="#6-编程思想" class="headerlink" title="6.编程思想"></a>6.编程思想</h2><p><strong>面向过程</strong>就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候再一个个依次调用就可以了</p>
<p><strong>面向对象</strong>是把事务分解成一个个对象，然后由对象之间分工与合作。是以对象功能来划分问题，而不是步骤</p>
<p><strong>构造函数</strong> 存在浪费内存的问题</p>
<h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><ol>
<li><p>原型</p>
<ul>
<li><p>构造函数通过原型分配的函数是所有对象所  <strong>共享的</strong></p>
</li>
<li><p>JavaScript规定，<strong>每一个构造函数都有一个prototype属性</strong>，指向另一个对象，所以我们也称为原型对象</p>
</li>
<li><p>这个对象可以挂载函数，对象实例化不会多次创建原型上函数，节约内存</p>
</li>
<li><p><strong>我们可以把那些不变的方法，直接定义在prototype对象上，这样所有对象的实例就可以共享这些方法</strong></p>
</li>
<li><p><strong>构造函数和原型对象中的this都指向  实例化对象</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例如：</span></span><br><span class="line"><span class="comment">//1. 公共的属性写到 构造函数里面</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Star</span>(<span class="params">uname, age</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">uname</span> = uname</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2. 公共的方法写到原型对象身上</span></span><br><span class="line"><span class="title class_">Star</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sing</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    consolo.<span class="title function_">log</span>(<span class="string">&#x27;唱歌&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> ldh = <span class="keyword">new</span> <span class="title class_">Star</span>(<span class="string">&#x27;刘德华&#x27;</span>, <span class="number">55</span>)</span><br><span class="line"><span class="keyword">const</span> zxy = <span class="keyword">new</span> <span class="title class_">Star</span>(<span class="string">&#x27;张学友&#x27;</span>, <span class="number">58</span>)</span><br><span class="line">ldh.<span class="title function_">sing</span>() <span class="comment">//唱歌</span></span><br><span class="line">zxy.<span class="title function_">sing</span>() <span class="comment">//唱歌</span></span><br><span class="line">consolo.<span class="title function_">log</span>(ldh.<span class="title function_">sing</span>() === zxy.<span class="title function_">sing</span>()) <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>constructor 属性</p>
<p>每个原型对象里面都有个constructor属性（constructor 构造函数）</p>
<p>作用：该属性<strong>指向</strong>该原型对象的<strong>构造函数</strong>，简单理解，就是<strong>指向我的爸爸，我是有爸爸的孩子</strong></p>
<p>使用场景：</p>
<p>如果有多个对象的方法，我们可以给原型对象采取对象形式赋值</p>
<p>但是这样就会覆盖构造函数原型对象原本的内容，这样修改后的原型对象 constructor 就不再指向当前构造函数。</p>
<p>此时，我们可以在修改后的原型对象中，添加一个constructor指向原来的构造函数</p>
</li>
<li><p>对象原型</p>
<p><strong>对象都会有一个属性  __ proto __</strong>  指向构造函数的prototype原型对象，之所以我们对象可以使用构造函数 prototype 原型对象的属性和方法，就是因为对象有  __ proto __  原型的存在。</p>
<p><img src="/../images/image-20231010195953911.png" alt="image-20231010195953911"></p>
<p><img src="/../images/image-20231010201941362.png" alt="image-20231010201941362"></p>
<p><img src="/../images/image-20231010202321354.png" alt="image-20231010202321354"></p>
<p>注意：</p>
<ul>
<li>__ proto __ 是js非标准属性</li>
<li>[[prototype]]和__ proto __意义相同</li>
<li>用来表明当前实例对象指向哪个原型对象prototype</li>
<li>__ proto __ 对象原型里面也有一个 constructor 属性，<strong>指向创建该实例对象的构造函数</strong></li>
</ul>
</li>
<li><p>原型继承</p>
<ol>
<li><p>封装 - 抽取公共部分</p>
</li>
<li><p>继承</p>
</li>
<li><p>问题：给其中一个实例对象添加方法，另一个实例对象也会添加这个方法</p>
<p>–原因：因为都使用了一个对象，根据引用类型的特点，他们都指向一个对象，修改一个都会被影响</p>
</li>
<li><p>解决：</p>
<p><strong>构造函数</strong></p>
<p>new 每次都会创建一个新的对象</p>
</li>
</ol>
</li>
<li><p>原型链</p>
<p>基于原型对象的继承使得不同构造函数的原型对象关联在一起，并且这种关联的关系是一种链状的解构，我们将原型对象的链状结构关系称为<strong>原型链</strong></p>
<p><img src="/../images/image-20231014204804760.png" alt="image-20231014204804760"></p>
<p><img src="/../images/image-20231014205917239.png" alt="image-20231014205917239"></p>
<p>查找规则：</p>
<ol>
<li><p>当访问一个对象的属性（包括方法）时，首先查找这个<strong>对象自身</strong>有没有该属性</p>
</li>
<li><p>如果没有就查找它的原型（也就是__ proto __ 指向的 <strong>prototype 原型对象</strong>）</p>
</li>
<li><p>如果还没有就查找原型对象的原型（<strong>Object的原型对象</strong>）</p>
</li>
<li><p>依此类推一直找到Object为止（<strong>null</strong>）</p>
</li>
<li><p>__ proto __ 对象原型的意义就在于为对象成员查找机制提供一个方向，或者说一条路线</p>
</li>
<li><p>可以使用 <strong>instanceof</strong> 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例如：</span></span><br><span class="line"><span class="keyword">function</span>(<span class="params"></span>) <span class="title class_">Peoson</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> ldh = <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ldh <span class="keyword">instanceof</span> <span class="title class_">Person</span>) <span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ldh <span class="keyword">instanceof</span> <span class="title class_">Object</span>) <span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ldh <span class="keyword">instanceof</span> <span class="title class_">Array</span>) <span class="comment">//false</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h2 id="7-深浅拷贝"><a href="#7-深浅拷贝" class="headerlink" title="7.深浅拷贝"></a>7.深浅拷贝</h2><h3 id="7-1-浅拷贝"><a href="#7-1-浅拷贝" class="headerlink" title="7.1 浅拷贝"></a>7.1 浅拷贝</h3><p>首先浅拷贝和深拷贝只针对引用类型</p>
<p>浅拷贝：拷贝的是地址</p>
<p><em>如果是简单数据类型拷贝值，引用数据类型拷贝的是地址（简单理解：如果是单层对象，没问题，如果有多层就有问题）</em></p>
<p><strong>常见方法</strong>：</p>
<ol>
<li><p>拷贝对象：Object.assgin() &#x2F; 展开运算符 { … obj } 拷贝对象</p>
</li>
<li><p>拷贝数组：Array.prototype.concat() 或者 [ … arr ]</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例如：</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">uname</span>: <span class="string">&#x27;pink&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//方法一</span></span><br><span class="line"><span class="keyword">const</span> o = &#123;...obj&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(o)</span><br><span class="line">o.<span class="property">age</span> = <span class="number">20</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(o) <span class="comment">//age = 20</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj) <span class="comment">//age = 18</span></span><br><span class="line"><span class="comment">//方法二：</span></span><br><span class="line"><span class="keyword">const</span> o = &#123;&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(o, obj)</span><br><span class="line">o.<span class="property">age</span> = <span class="number">20</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(o) <span class="comment">//age = 20</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj) <span class="comment">//age = 18</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="7-2-深拷贝"><a href="#7-2-深拷贝" class="headerlink" title="7.2 深拷贝"></a>7.2 深拷贝</h3><p>深拷贝：拷贝的是对象，不是地址</p>
<p><strong>常见方法：</strong></p>
<ol>
<li><p>通过递归实现深拷贝</p>
<p>函数递归：</p>
<p><strong>如果一个函数在内部可以调用其本身，那么这个函数就是递归函数</strong></p>
<ul>
<li><p>简单理解：函数内部自己调用自己，这个函数就是递归函数</p>
</li>
<li><p>递归函数的作用和循环效果类似</p>
</li>
<li><p>由于递归很容易发生 “栈溢出” 错误（stack overflow），所以<strong>必须要加退出条件 return</strong> </p>
</li>
<li><pre><code class="js">//例如：
let i = 1
function fn() &#123;
    console.log(`这是第$&#123;i&#125;次`)
    if(i &gt;= 6) &#123;
        return 
    &#125;
    i ++
    fn()
&#125;
fn()
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**利用递归函数实现 setTimeout 模拟 setInterval 效果**</span><br><span class="line"></span><br><span class="line">```js</span><br><span class="line">function getTime() &#123;</span><br><span class="line">    document.querySelector(&#x27;div&#x27;).innerHTML = new Date()</span><br><span class="line">    .toLocaleString()</span><br><span class="line">    setTimeout(getTime, 1000);</span><br><span class="line">&#125;</span><br><span class="line">getTime()</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
<li><p>lodash &#x2F; cloneDeep</p>
<p>js库lodash里面cloneDeep内部实现了深拷贝</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例如：</span></span><br><span class="line">&lt;script src=<span class="string">&quot;./lodash.min.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">const</span> obj = &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">uname</span>: <span class="string">&#x27;pink&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">age</span>: <span class="number">18</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">hobby</span>: [<span class="string">&#x27;乒乓球&#x27;</span>, <span class="string">&#x27;足球&#x27;</span>],</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">family</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="attr">baby</span>: <span class="string">&#x27;小pink&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">const</span> o = _.<span class="title function_">cloneDeep</span>(obj)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(o);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    o.<span class="property">family</span>.<span class="property">baby</span> = <span class="string">&#x27;老pink&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(obj);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>通过JSON.stringfy() 实现</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例如：</span></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">const</span> obj = &#123;</span><br><span class="line">        <span class="attr">uname</span>: <span class="string">&#x27;pink&#x27;</span>,</span><br><span class="line">        <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">        <span class="attr">hobby</span>: [<span class="string">&#x27;乒乓球&#x27;</span>, <span class="string">&#x27;足球&#x27;</span>],</span><br><span class="line">        <span class="attr">family</span>: &#123;</span><br><span class="line">            <span class="attr">baby</span>: <span class="string">&#x27;小pink&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把对象转换为 JSON 字符串</span></span><br><span class="line">    <span class="comment">// JSON.stringify(obj)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> o = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj))</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(o);</span><br><span class="line">    o.<span class="property">family</span>.<span class="property">baby</span> = <span class="string">&#x27;123&#x27;</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(obj);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="8-异常处理"><a href="#8-异常处理" class="headerlink" title="8.异常处理"></a>8.异常处理</h2><ol>
<li><p>throw 抛异常</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例如：</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!x || !y) &#123;</span><br><span class="line">        <span class="comment">// throw &#x27;没有参数传递进来&#x27;</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;没有参数传递进来&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">fn</span>());</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ol>
<li>throw抛出异常信息，程序也会终止执行</li>
<li>throw后面跟的是错误提示信息</li>
<li>Error对象配合throw使用，能够设置更详细的错误信息</li>
</ol>
</li>
<li><p>try &#x2F; catch 捕获异常</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例如：</span></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 可能发送错误的代码  要写到try</span></span><br><span class="line">            <span class="keyword">const</span> p = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.p&#x27;</span>)</span><br><span class="line">            p.<span class="property">style</span>.<span class="property">color</span> = <span class="string">&#x27;red&#x27;</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">            <span class="comment">// 拦截错误，提示浏览器提供的错误信息，但是不中断程序的		执行</span></span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(err.<span class="property">message</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;你看看，选择器错误了吧&#x27;</span>)</span><br><span class="line">            <span class="comment">// 需要加return 中断程序</span></span><br><span class="line">            <span class="comment">// return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 不管你程序对不对，一定会执行的代码</span></span><br><span class="line">            <span class="title function_">alert</span>(<span class="string">&#x27;弹出对话框&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">11</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">fn</span>()</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ol>
<li>try…catch 用于捕获错误信息</li>
<li>将预估可能发生错误的代码写在try代码段中</li>
<li>如果try代码段中出现错误后，会执行catch代码段，并截获到错误信息</li>
<li>finally 不管是否有错误，都会执行</li>
</ol>
</li>
<li><p>debugger</p>
</li>
</ol>
<h2 id="9-处理this"><a href="#9-处理this" class="headerlink" title="9.处理this"></a>9.处理this</h2><h3 id="9-1-this指向"><a href="#9-1-this指向" class="headerlink" title="9.1 this指向"></a>9.1 this指向</h3><p><strong>普通函数</strong>没有明确调用者时this值为window，严格模式下没有调用者时this的值为undefined</p>
<p><strong>箭头函数</strong>中的this与普通函数完全不同，也不受调用方式的影响，事实上<strong>箭头函数中并不存在this</strong>！</p>
<ol>
<li>箭头函数会默认帮我们绑定外层this的值，所以在箭头函数中this的值和外层的this是一样的</li>
<li>箭头函数中的this引用的就是最近作用域中的this</li>
<li>向外层作用域中，一层一层查找this，直到有this的定义</li>
</ol>
<p><strong>注意情况1：</strong></p>
<p>在开发中【使用箭头函数前需要考虑函数中this 的值】，事件回调函数使用箭头函数时，this为全局的window，因此DOM事件回调函数<strong>如果里面需要</strong>DOM对象的this，则不推荐使用箭头函数。</p>
<p><strong>注意情况2：</strong></p>
<p>同样由于箭头函数this的原因，基于原型的面向对象也不推荐采用箭头函数。</p>
<h3 id="9-2-改变this"><a href="#9-2-改变this" class="headerlink" title="9.2 改变this"></a>9.2 改变this</h3><p>JavaScript中还允许指定函数中的指向，有3个方法可以动态指定普通函数中this的指向</p>
<p>call（）——了解</p>
<p>语法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun.<span class="title function_">call</span>(thisArg, arg1, arg2,...)</span><br></pre></td></tr></table></figure>

<ul>
<li>thisArg：在fun函数运行时指定的this值</li>
<li>arg1，arg2：传递的其他参数</li>
<li>返回值就是函数的返回值，因为它就是调用函数</li>
</ul>
<p>apply（）——理解</p>
<p>语法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun.<span class="title function_">apply</span>(thisArg,[argsArray])</span><br></pre></td></tr></table></figure>

<ul>
<li>thisArg：在fun函数运行时指定的this值</li>
<li>argsArray：传递的值，必须包含在数组里面</li>
<li>返回值就是函数的返回值，因为它就是调用函数</li>
<li>因此apply主要跟数组有关系，比如使用Math.max() 求数组的最大值</li>
</ul>
<p>bind（）——重点</p>
<p>bind（）方法不会调用函数。但是能改变函数内部this指向</p>
<p>语法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun.<span class="title function_">bind</span>(thisArg, arg1, arg2,...)</span><br></pre></td></tr></table></figure>

<ul>
<li>thisArg：在fun函数运行时指定的this值</li>
<li>arg1，arg2：传递的其他参数</li>
<li>返回由指定的this值和初始化参数改造的<strong>原函数拷贝（新函数）</strong></li>
<li>因此当我们只是想改变this指向，并且不想调用这个函数的时候，可以使用bind，比如改变定时器内部的this指向</li>
</ul>
<h3 id="9-3-call-apply-bind-总结"><a href="#9-3-call-apply-bind-总结" class="headerlink" title="9.3 call apply bind 总结"></a>9.3 call apply bind 总结</h3><ol>
<li><p>相同点：</p>
<p>都可以改变函数内部的this指向</p>
</li>
<li><p>区别点：</p>
<ul>
<li>call 和apply 会调用函数，并且改变函数内部this指向</li>
<li>call 和 apply 传递的参数不一样，call 传递参数 aru1，aru2…形式 apply 必须数组形式[arg]</li>
<li><strong>bind 不会调用函数，可以改变函数内部 this 指向</strong></li>
</ul>
</li>
<li><p>主要应用场景：</p>
<ul>
<li>call 调用函数并且可以传递参数</li>
<li>apply 经常跟数组有关系，比如借助于数学对象实现数组最大值最小值</li>
<li><strong>bind 不调用函数，但是还想改变this指向，比如改变定时器内部的this指向</strong></li>
</ul>
</li>
</ol>
<h2 id="10-防抖"><a href="#10-防抖" class="headerlink" title="10.防抖"></a>10.防抖</h2><p>防抖：单位时间内，频繁触发事件，只执行最后一次</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例如：</span></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="comment">// 利用防抖实现性能优化</span></span><br><span class="line">    <span class="comment">//需求： 鼠标在盒子上移动，里面的数字就会变化 +1</span></span><br><span class="line">    <span class="keyword">const</span> box = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.box&#x27;</span>)</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">1</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">mouseMove</span>(<span class="params"></span>) &#123;</span><br><span class="line">        box.<span class="property">innerHTML</span> = i ++</span><br><span class="line">    	<span class="comment">// 如果里面存在大量消耗性能的代码，比如dom操作，比如数据处		理，可能造成卡顿</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加事件</span></span><br><span class="line">    <span class="comment">// box.addEventListener(&#x27;mousemove&#x27;, mouseMove)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 利用Lodash库实现防抖 - 500毫秒之后采取+1</span></span><br><span class="line">    <span class="comment">//语法： _.debounce(fun, 时间)</span></span><br><span class="line">    <span class="comment">// box.addEventListener(&#x27;mousemove&#x27;, _.debounce(mouseMove, 500))</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 手写防抖函数</span></span><br><span class="line">    <span class="comment">//核心是利用setTimeout定时器来实现</span></span><br><span class="line">    <span class="comment">// 1. 声明定时器变量</span></span><br><span class="line">    <span class="comment">// 2. 每次鼠标移动（事件触发）的时候都要先判断是否有定时器，如果有先清除以前的定时器</span></span><br><span class="line">    <span class="comment">// 3. 如果没有定时器，则开启定时器，存入到定时器变量里面</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">fn, t</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> timer</span><br><span class="line">        <span class="comment">//return 返回一个匿名函数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="comment">//2.3.4</span></span><br><span class="line">            <span class="keyword">if</span>(timer) <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">            timer = <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">                <span class="title function_">fn</span>() <span class="comment">//加小括号调用fn函数</span></span><br><span class="line">            &#125;,t)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    box.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>, <span class="title function_">debounce</span>(mouseMove, <span class="number">500</span>))</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h2 id="11-节流-throttle"><a href="#11-节流-throttle" class="headerlink" title="11.节流 - throttle"></a>11.节流 - throttle</h2><p>节流：单位时间内，频繁触发事件，<strong>只执行一次</strong></p>
<p>使用场景：鼠标移动 mousemove、页面尺寸缩放 resize、滚动条滚动scroll等</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例如：</span></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="comment">// 利用节流实现性能优化</span></span><br><span class="line">    <span class="comment">//需求： 鼠标在盒子上移动，里面的数字就会变化 +1</span></span><br><span class="line">    <span class="keyword">const</span> box = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.box&#x27;</span>)</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">1</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">mouseMove</span>(<span class="params"></span>) &#123;</span><br><span class="line">        box.<span class="property">innerHTML</span> = i ++</span><br><span class="line">        <span class="comment">// 如果里面存在大量消耗性能的代码，比如dom操作，比如数据处理，可能造成卡顿</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加事件</span></span><br><span class="line">    <span class="comment">// box.addEventListener(&#x27;mousemove&#x27;, mouseMove)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 利用Lodash库实现节流 - 500毫秒之后采取+1</span></span><br><span class="line">    <span class="comment">//语法： _.throttle(fun, 时间)</span></span><br><span class="line">    <span class="comment">// box.addEventListener(&#x27;mousemove&#x27;, _.throttle(mouseMove, 500))</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 手写节流函数</span></span><br><span class="line">    <span class="comment">//核心是利用setTimeout定时器来实现</span></span><br><span class="line">    <span class="comment">// 1. 声明定时器变量</span></span><br><span class="line">    <span class="comment">// 2. 当鼠标每次滑动都先判断是否有定时器了，如果有定时器则不开启新定时器</span></span><br><span class="line">    <span class="comment">// 3. 如果没有定时器，则开启定时器，存入到定时器变量里面</span></span><br><span class="line">    <span class="comment">// 3.1 定时器里面调用执行的函数</span></span><br><span class="line">    <span class="comment">// 3.1 定时器里面要把定时器情清空</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">fn, t</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!time) &#123;</span><br><span class="line">                timer = <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">                    <span class="title function_">fn</span>() <span class="comment">//加小括号调用fn函数</span></span><br><span class="line">                    <span class="comment">// 清空定时器</span></span><br><span class="line">                    <span class="comment">// 在setTimeout中是无法删除定时器的，因为定时器还在运作，所以使用timer = null，而不是clearTimeout（timer）</span></span><br><span class="line">                    timer = <span class="literal">null</span></span><br><span class="line">                &#125;,t)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	box.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>, <span class="title function_">throttle</span>(mouseMove, <span class="number">3000</span>))</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<p><strong>总结：</strong></p>
<p><img src="/../images/image-20231021180615773.png" alt="image-20231021180615773"></p>
<h2 id="12-使用-Promise"><a href="#12-使用-Promise" class="headerlink" title="12. 使用 Promise"></a>12. 使用 Promise</h2><p>Promise链式调用的好处在于避免了回调地狱。</p>
<p>在 <code>then</code> 回调中始<strong>终返回 Promise</strong> 是非常重要的，即使 Promise 总是兑现为 <code>undefined</code>。如果上一个处理器启动了一个 Promise 但并没有返回它，那么就没有办法再追踪它的敲定状态了，这个 Promise 就是“漂浮”的。</p>
<p><strong>四个组合工具：</strong><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/all"><code>Promise.all()</code></a>、<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/allSettled"><code>Promise.allSettled()</code></a>、<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/any"><code>Promise.any()</code></a> 和 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/race"><code>Promise.race()</code></a>。</p>
<ul>
<li>Promise.all()</li>
<li>Promise.allSettled()</li>
<li>Promise.any()</li>
<li>Promise.race()</li>
</ul>
<p>我们可以同时启动所有操作，再等待它们全部完成，就像这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>([<span class="title function_">func1</span>(), <span class="title function_">func2</span>(), <span class="title function_">func3</span>()]).<span class="title function_">then</span>(<span class="function">(<span class="params">[result1, result2, result3]</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">/* 使用 result1、result2 和 result3 */</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>如果数组中的某个 Promise 被拒绝，<code>Promise.all()</code> 就会立即拒绝返回的 Promise，并终止其他操作。这可能会导致一些意外的状态或行为。<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/allSettled"><code>Promise.allSettled()</code></a> 是另一个组合工具，它会等待所有操作完成后再处理返回的 Promise。</p>
<p><strong>时序：</strong></p>
<p>任务队列 vs. 微任务</p>
<p>Promise 回调被处理为<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTML_DOM_API/Microtask_guide">微任务</a>，而 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/setTimeout"><code>setTimeout()</code></a> 回调被处理为任务队列。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Promise 执行函数&quot;</span>);</span><br><span class="line">  <span class="title function_">resolve</span>();</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Promise 回调（.then）&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;新一轮事件循环：Promise（已完成）&quot;</span>, promise);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Promise（队列中）&quot;</span>, promise);</span><br></pre></td></tr></table></figure>

<p>上述代码的输出如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span> 执行函数</span><br><span class="line"><span class="title class_">Promise</span>（队列中）<span class="title class_">Promise</span> &#123;&lt;pending&gt;&#125;</span><br><span class="line"><span class="title class_">Promise</span> 回调（.<span class="property">then</span>）</span><br><span class="line">新一轮事件循环：<span class="title class_">Promise</span>（已完成）<span class="title class_">Promise</span> &#123;&lt;fulfilled&gt;&#125;</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://wakuwaku233.github.io">薄苏</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://wakuwaku233.github.io/2023/09/23/js%E5%92%8CAPIs/">https://wakuwaku233.github.io/2023/09/23/js%E5%92%8CAPIs/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://wakuwaku233.github.io" target="_blank">薄苏的桃花坞</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/js/">js</a></div><div class="post_share"><div class="social-share" data-image="/images/bg4.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/2023/09/23/jquery%E7%9F%A5%E8%AF%86/" title="jQuery"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">jQuery</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/images/%E9%98%BF%E5%B0%BC%E4%BA%9A.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">薄苏</div><div class="author-info__description">希望成为富婆❤，谁能莫名其妙给我打一百万！！！啊！！！</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">8</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81Js%E5%9F%BA%E7%A1%80"><span class="toc-number">1.</span> <span class="toc-text">一、Js基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%BB%84%E6%88%90123"><span class="toc-number">1.1.</span> <span class="toc-text">1.组成123</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA"><span class="toc-number">1.2.</span> <span class="toc-text">2.输入和输出</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%8F%98%E9%87%8F"><span class="toc-number">1.3.</span> <span class="toc-text">3.变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%B8%B8%E9%87%8F"><span class="toc-number">1.4.</span> <span class="toc-text">4.常量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.5.</span> <span class="toc-text">5.数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E6%A8%A1%E6%9D%BF%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.6.</span> <span class="toc-text">6.模板字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E6%8E%A7%E5%88%B6%E5%8F%B0%E8%BE%93%E5%87%BA%E8%AF%AD%E5%8F%A5%E5%92%8C%E6%A3%80%E6%B5%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.7.</span> <span class="toc-text">7.控制台输出语句和检测数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.8.</span> <span class="toc-text">8.隐式转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E6%98%BE%E5%BC%8F%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.9.</span> <span class="toc-text">9.显式转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.10.</span> <span class="toc-text">10.比较运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-%E6%93%8D%E4%BD%9C%E6%95%B0%E7%BB%84"><span class="toc-number">1.11.</span> <span class="toc-text">11.操作数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-%E5%87%BD%E6%95%B0"><span class="toc-number">1.12.</span> <span class="toc-text">12.函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0"><span class="toc-number">1.12.1.</span> <span class="toc-text">匿名函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-%E9%80%BB%E8%BE%91%E4%B8%AD%E6%96%AD"><span class="toc-number">1.13.</span> <span class="toc-text">13.逻辑中断</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-%E8%BD%AC%E6%8D%A2%E4%B8%BABoolean%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.14.</span> <span class="toc-text">14.转换为Boolean类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.15.</span> <span class="toc-text">15.对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-%E7%AE%80%E5%8D%95%E5%92%8C%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.16.</span> <span class="toc-text">16.简单和引用数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-%E5%BE%AA%E7%8E%AF%E4%B8%8E%E8%BF%AD%E4%BB%A3"><span class="toc-number">1.17.</span> <span class="toc-text">17. 循环与迭代</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81APIs"><span class="toc-number">2.</span> <span class="toc-text">二、APIs</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%9F%BA%E6%9C%AC%E8%AE%A4%E7%9F%A5"><span class="toc-number">2.1.</span> <span class="toc-text">1.基本认知</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BD%9C%E7%94%A8%E5%92%8C%E5%88%86%E7%B1%BB"><span class="toc-number">2.1.1.</span> <span class="toc-text">1.作用和分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-DOM%E6%A0%91%EF%BC%9A"><span class="toc-number">2.1.2.</span> <span class="toc-text">2.DOM树：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E8%8E%B7%E5%8F%96DOM%E5%85%83%E7%B4%A0"><span class="toc-number">2.2.</span> <span class="toc-text">2.获取DOM元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%93%8D%E4%BD%9C%E5%85%83%E7%B4%A0%E5%86%85%E5%AE%B9"><span class="toc-number">2.3.</span> <span class="toc-text">3.操作元素内容</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%93%8D%E4%BD%9C%E5%85%83%E7%B4%A0%E5%B1%9E%E6%80%A7"><span class="toc-number">2.4.</span> <span class="toc-text">4.操作元素属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC"><span class="toc-number">2.5.</span> <span class="toc-text">5.事件监听</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E4%BA%8B%E4%BB%B6%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.6.</span> <span class="toc-text">6.事件类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.6.1.</span> <span class="toc-text">事件对象</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E7%8E%AF%E5%A2%83%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.7.</span> <span class="toc-text">7.环境对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0"><span class="toc-number">2.8.</span> <span class="toc-text">8.回调函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E4%BA%8B%E4%BB%B6%E6%B5%81"><span class="toc-number">2.9.</span> <span class="toc-text">9.事件流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98"><span class="toc-number">2.10.</span> <span class="toc-text">10.事件委托</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-%E5%85%B6%E4%BB%96%E4%BA%8B%E4%BB%B6"><span class="toc-number">2.11.</span> <span class="toc-text">11.其他事件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-%E5%85%83%E7%B4%A0%E7%9A%84%E5%B0%BA%E5%AF%B8%E4%B8%8E%E4%BD%8D%E7%BD%AE"><span class="toc-number">2.12.</span> <span class="toc-text">12.元素的尺寸与位置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-%E6%97%A5%E6%9C%9F%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.13.</span> <span class="toc-text">13.日期对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A5%E6%9C%9F%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.13.1.</span> <span class="toc-text">日期对象</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-%E8%8A%82%E7%82%B9%E6%93%8D%E4%BD%9C"><span class="toc-number">2.14.</span> <span class="toc-text">14.节点操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-M%E7%AB%AF%E4%BA%8B%E4%BB%B6"><span class="toc-number">2.15.</span> <span class="toc-text">15.M端事件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-%E6%8F%92%E4%BB%B6"><span class="toc-number">2.16.</span> <span class="toc-text">16.插件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-Window%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.17.</span> <span class="toc-text">17.Window对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-BOM"><span class="toc-number">2.17.1.</span> <span class="toc-text">1.BOM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%AE%9A%E6%97%B6%E5%99%A8-%E5%BB%B6%E6%97%B6%E5%87%BD%E6%95%B0"><span class="toc-number">2.17.2.</span> <span class="toc-text">2.定时器-延时函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-JS%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6%EF%BC%88%E5%90%8C%E6%AD%A5%E3%80%81%E5%BC%82%E6%AD%A5%EF%BC%89"><span class="toc-number">2.17.3.</span> <span class="toc-text">3.JS执行机制（同步、异步）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-location%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.17.4.</span> <span class="toc-text">4.location对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-navigator%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.17.5.</span> <span class="toc-text">5.navigator对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-histroy%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.17.6.</span> <span class="toc-text">6.histroy对象</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8"><span class="toc-number">2.18.</span> <span class="toc-text">18.本地存储</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.18.1.</span> <span class="toc-text">1.本地存储介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%E5%88%86%E7%B1%BB"><span class="toc-number">2.18.2.</span> <span class="toc-text">2.本地存储分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%AD%98%E5%82%A8%E5%A4%8D%E6%9D%82%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.18.3.</span> <span class="toc-text">3.存储复杂数据类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5%E6%96%B0%E6%80%9D%E8%B7%AF"><span class="toc-number">2.19.</span> <span class="toc-text">19.字符串拼接新思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">2.20.</span> <span class="toc-text">20.正则表达式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-%E7%B4%A2%E5%BC%95%E9%9B%86%E5%90%88%E7%B1%BB"><span class="toc-number">2.21.</span> <span class="toc-text">21. 索引集合类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-number">2.21.1.</span> <span class="toc-text">数组方法：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81js%E8%BF%9B%E9%98%B6"><span class="toc-number">3.</span> <span class="toc-text">三、js进阶</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">3.1.</span> <span class="toc-text">1.作用域</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E5%B1%80%E9%83%A8%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">3.1.1.</span> <span class="toc-text">1.1 局部作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E5%85%A8%E5%B1%80-%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">3.1.2.</span> <span class="toc-text">1.2 全局 作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE"><span class="toc-number">3.1.3.</span> <span class="toc-text">1.3 作用域链</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="toc-number">3.1.4.</span> <span class="toc-text">1.4 垃圾回收机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-%E9%97%AD%E5%8C%85"><span class="toc-number">3.1.5.</span> <span class="toc-text">1.5 闭包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87"><span class="toc-number">3.1.6.</span> <span class="toc-text">1.6 变量提升</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-7-%E4%BD%BF%E7%94%A8-arguments-%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.1.7.</span> <span class="toc-text">1.7 使用 arguments 对象</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6"><span class="toc-number">3.2.</span> <span class="toc-text">2.函数进阶</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%87%BD%E6%95%B0%E6%8F%90%E5%8D%87"><span class="toc-number">3.2.1.</span> <span class="toc-text">2.1 函数提升</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="toc-number">3.2.2.</span> <span class="toc-text">2.2 函数参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%89"><span class="toc-number">3.2.3.</span> <span class="toc-text">2.3 箭头函数（重要）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC"><span class="toc-number">3.3.</span> <span class="toc-text">3.解构赋值</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E6%95%B0%E7%BB%84%E8%A7%A3%E6%9E%84"><span class="toc-number">3.3.1.</span> <span class="toc-text">3.1 数组解构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E5%AF%B9%E8%B1%A1%E8%A7%A3%E6%9E%84"><span class="toc-number">3.3.2.</span> <span class="toc-text">3.2 对象解构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%B7%B1%E5%85%A5%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.4.</span> <span class="toc-text">4.深入对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">3.4.1.</span> <span class="toc-text">4.1 创建对象的三种方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">3.4.2.</span> <span class="toc-text">4.2 构造函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%86%85%E7%BD%AE%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">3.5.</span> <span class="toc-text">5.内置构造函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3"><span class="toc-number">3.6.</span> <span class="toc-text">6.编程思想</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B"><span class="toc-number">3.6.1.</span> <span class="toc-text">原型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">3.7.</span> <span class="toc-text">7.深浅拷贝</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">3.7.1.</span> <span class="toc-text">7.1 浅拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="toc-number">3.7.2.</span> <span class="toc-text">7.2 深拷贝</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">3.8.</span> <span class="toc-text">8.异常处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E5%A4%84%E7%90%86this"><span class="toc-number">3.9.</span> <span class="toc-text">9.处理this</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1-this%E6%8C%87%E5%90%91"><span class="toc-number">3.9.1.</span> <span class="toc-text">9.1 this指向</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-%E6%94%B9%E5%8F%98this"><span class="toc-number">3.9.2.</span> <span class="toc-text">9.2 改变this</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-call-apply-bind-%E6%80%BB%E7%BB%93"><span class="toc-number">3.9.3.</span> <span class="toc-text">9.3 call apply bind 总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E9%98%B2%E6%8A%96"><span class="toc-number">3.10.</span> <span class="toc-text">10.防抖</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-%E8%8A%82%E6%B5%81-throttle"><span class="toc-number">3.11.</span> <span class="toc-text">11.节流 - throttle</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-%E4%BD%BF%E7%94%A8-Promise"><span class="toc-number">3.12.</span> <span class="toc-text">12. 使用 Promise</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/09/24/%E7%9F%A5%E8%AF%86%E5%B7%A9%E5%9B%BA/" title="知识巩固"><img src="/images/bg5.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="知识巩固"/></a><div class="content"><a class="title" href="/2024/09/24/%E7%9F%A5%E8%AF%86%E5%B7%A9%E5%9B%BA/" title="知识巩固">知识巩固</a><time datetime="2024-09-24T11:20:27.156Z" title="发表于 2024-09-24 19:20:27">2024-09-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/09/12/%E9%9D%A2%E7%BB%8F/" title="面经"><img src="/images/bg3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="面经"/></a><div class="content"><a class="title" href="/2024/09/12/%E9%9D%A2%E7%BB%8F/" title="面经">面经</a><time datetime="2024-09-12T03:00:14.295Z" title="发表于 2024-09-12 11:00:14">2024-09-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/06/05/webpack/" title="webpack">webpack</a><time datetime="2024-06-05T04:25:31.882Z" title="发表于 2024-06-05 12:25:31">2024-06-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/04/07/dailyProblem/" title="日常问题"><img src="/images/bg4.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="日常问题"/></a><div class="content"><a class="title" href="/2024/04/07/dailyProblem/" title="日常问题">日常问题</a><time datetime="2024-04-07T11:37:15.353Z" title="发表于 2024-04-07 19:37:15">2024-04-07</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/12/05/vue/" title="vue2+vue3">vue2+vue3</a><time datetime="2023-12-05T13:58:39.649Z" title="发表于 2023-12-05 21:58:39">2023-12-05</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 薄苏</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>